[{"title":"使用Caddy转发内网的Minecraft服务器小结","path":"2024/06/summary-caddy-l4-minecraft/","text":"接上文，我搭建了一个tailscale虚拟内网，把自己的各种设备在一个虚拟网段中组织了起来。于是，通过一个拥有外网IP的节点，就可以把自己内网的Minecraft服务器转发到外网，算是一个内网穿透的新选择。 相比nginx，我更加喜欢配置简单清晰的caddy。而且还有最新最潮的自动SSL功能，实在是降低心智负担的好选择。但是，caddy和nginx都属于HTTP层的转发代理。众所周知，Minecraft使用了自定义的TCP协议进行网络通信，所以无论是nginx还是caddy，都需要通过安装额外插件的方式来支撑TCP转发。 xcaddyxcaddy（caddyserver&#x2F;xcaddy: Build Caddy with plugins (github.com)）是一个编译、调试和管理caddy插件的项目。也是基于Go，所以我们需要先安装一个Go环境。 按照Go官方推荐的安装方法，我们把go环境（也就是GOROOT）安装到/usr/local/go，默认的GOPATH则是在~/go。 12345wget https://go.dev/dl/go1.22.4.linux-amd64.tar.gzrm -rf /usr/local/gotar -C /usr/local -xcf go1.22.4.linux-amd64.tar.gzecho &quot;export PATH=$PATH:/usr/local/go/bin&quot; | tee -a /etc/profilego version 此时go已经安装完毕，打开go111module选项： 1go env -w GO111MODULE=auto 接着编译安装xcaddy： 1go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest 此时xcaddy可执行文件被安装到了~/go/bin/xcaddy caddy-l4caddy-l4（mholt&#x2F;caddy-l4: Layer 4 (TCP&#x2F;UDP) app for Caddy (github.com)）是caddy的一个TCP层代理插件，可以让caddy支持TCP&#x2F;UDP&#x2F;SOCKS等第四层的网络代理。 caddy的插件都将通过源码的方式编译到二进制文件中，也就是说我们需要通过xcaddy编译一个具有caddy-l4插件的二进制文件并替换我们已有的caddy可执行文件： 1~/go/bin/xcaddy build --with github.com/mholt/caddy-l4 等待编译结束，此时带有caddy-l4插件的caddy将会出现在当前路径中，我们使用这个caddy将原来的caddy替换。 12mv caddy /usr/bin/caddysystemctl restart caddy 此时caddy-l4安装完成，接下来我们来配置caddy。 使用JSON配置文件鉴于caddy-l4模块目前并不支持Caddyfile，所以我们将使用JSON格式的配置文件来运行caddy。不过该模块的Caddyfile支持也是在不断地推进当中了，不远的将来也许我们可以继续使用Caddyfile（Feature Request: Support Caddyfile · Issue #16 · mholt&#x2F;caddy-l4 (github.com)）。 caddy的JSON格式配置文件的说明可以从官网查看，我们可以通过以下指令将Caddyfile转换到JSON格式的配置文件： 1caddy adapt --config /etc/caddy/Caddyfile --pretty &gt;&gt; /etc/caddy/caddy.json 可以看到官方默认的代理都在apps.http中，caddy-l4的配置将在app.layer4中，格式和http类似。具体的matcher和handler列表可以在github项目主页看到（但很可惜并没有相关说明，具体的使用方法只能通过看代码或者通过灵感检定获知）。 我的minecraft服务器在tailscale内网的100.64.0.17:25565端口，于是可以这样编写配置文件： 1234567891011121314151617181920212223&#123; &quot;apps&quot;: &#123; &quot;layer4&quot;: &#123; &quot;servers&quot;: &#123; &quot;minecraft&quot;: &#123; &quot;listen&quot;: [&quot;0.0.0.0:23343&quot;], &quot;routes&quot;: [ &#123; &quot;handle&quot;: [ &#123; &quot;handler&quot;: &quot;proxy&quot;, &quot;upstreams&quot;: [ &#123; &quot;dial&quot;: [&quot;100.64.0.17:25565&quot;] &#125; ] &#125; ] &#125; ] &#125; &#125; &#125; &#125;&#125; 此配置文件将监听23343端口的TCP请求，并将其转发到100.64.17的25565端口。 更改caddy服务使用的启动选项： 12345# /usr/lib/systemd/system/caddy.service# 其他选项省略[Service]ExecStart=/usr/bin/caddy run --environ --config /etc/caddy/caddy.jsonExecReload=/usr/bin/caddy reload --config /etc/caddy/caddy.json --force 重载并重启caddy服务： 12systemctl daemon-reloadsystemctl restart caddy 在Minecraft中把指定IP的23343端口添加到服务器列表并刷新，可以看到当前已经联通（别忘了在VPS控制台放开指定端口）。查看caddy的日志可以发现确实收到了查询服务器状态的请求： 1journalctl -u caddy 设置SRV转发通过SRV转发，可以让访问Minecraft服务器时省略掉指定端口。 以腾讯云DNS为例，将_minecraft._tcp.mc记录转发到0 5 23343 xxx.xxx.xxx.xxx.。含义是将通过mc子域名访问的minecraft协议tcp请求转发到xxx.xxx.xxx.xxx:23343，优先级是0，权重是5。 等待DNS缓存服务器刷新。然后就可以使用mc.yourdomain.com访问Minecraft服务器了。 也可以通过以下windows指令检查SRV解析情况： 1nslookup.exe -q=srv _minecraft._tcp.mc.yourdomain.com 到此就大功告成了！可喜可贺，可喜可贺。"},{"title":"Tailscale虚拟内网部署小结","path":"2024/04/summary-tailscale-allthrough/","text":"手头的设备越来越多了，加上还有很多需要合并的VPS。偶然发现还有tailscale这种好东西，遂折腾之。体验了小一个月，还是挺好用的，简单总结一下从全自主部署到各种子业务的折腾流程。 部署规划开始折腾这东西的契机主要有两点。 第一是之前嫌麻烦，几乎每个web项目都会单独开一台阿里云轻量服务器部署。导致有七八个VPS同时需要续费，并且每台机器都只有一两个几乎没有性能损耗的服务。这种行为实在有些奢侈，而且轻量服务器也是有数量上限的。遂准备通过组网转发的方式，让所有的服务集中到家里的物理服务器上，同时分别将自用网站反代到虚拟内网，公开网站通过虚拟内网的对外转发专用机器反代到公网。 第二是跟着我历练多年的老游戏本逐渐变得卡卡的，而家里的台式不能移动。组好虚拟内网之后可以通过各种各样的远程桌面方案随时随地（在有网的地方）快乐游戏。 网络层通过数台阿里云当作中转服务器和协调服务器，组建headscale服务端。通过各个设备的tailscale客户端将设备接入虚拟局域网，全设备尽可能地使用IPv6进行NAT穿透以达成低延迟互通的效果。 应用层一台迷你主机作为物理服务器整合现有的web服务，通过Caddy反代到各种地址。 Sunshine+Moonlight的游戏远程桌面串流，配合RDP以及米家达成无头开关机以及远程桌面流程。 自建Tailscale虚拟局域网Tailscale是一款基于WireGuard的虚拟局域网解决方案，可以将若干台机器放置在一个逻辑上的局域网中，并尽可能地使用NAT穿透来实现设备之间的p2p直连。 协调服务器负责整个虚拟局域网的用户管理等逻辑层面的功能，中转服务器负责NAT穿透中或者穿透失败时进行设备之间的中转通信。官方有可以免费使用的服务器，但是需要注册账户，并且官方提供的中转服务器延迟通常比较高。所以，在这里选择了全自建的方案来达到全流程可控的状态。 环境阿里云轻量服务器HK Ubuntu 20.04 LTS 安装Headscale协调服务器Headscale是对Tailscale协调服务器的开源实现。 首先进行一个下载和安装： 1234# 可以先去release页查看下最新版本号并替换# https://github.com/juanfont/headscale/releases/latestwget https://github.com/juanfont/headscale/releases/download/v0.22.3/headscale_0.22.3_linux_amd64.debdpkg -i headscale_0.22.3_linux_amd64.deb 简单调整一下配置，和一般的软件一样都在etc里，每个配置项都有详细的注释，就不一一说明了。 1vim /etc/headscale/config.yaml 值得一提的一些配置项： 123456789101112131415161718192021222324252627# 协调服务器server_url: https://your.domain.com:port# 监听地址listen_addr: 127.0.0.1:8080# 内网网段, 推荐把IPv4地址放在上面(IPv6地址太难输入了)ip_prefixes: - 100.64.0.0/10 - fd7a:ll5c:ale0::/48# 内置的DERP, 不推荐打开, 功能不完整derp: server: enabled: false # DERP服务列表 urls: - https://your.domain.com:port/derp/derp.json # 稍后部署的DERP配置文件地址 - https://controlplane.tailscale.com/derpmap/default # 官方中转, 自信可以删掉# DNS相关配置dns_config: # 重载本地DNS override_local_dns: true nameservers: - 223.5.5.5 # 阿里DNS - 8.8.8.8 # 咕咕噜公共DNS # 开启魔法DNS # 开启后网内设备可以通过(设备名称[.base_domain])互相访问 magic_dns: true base_domain: example.com # 不宜设置过长, 血的教训 设置daemon开机自启动并且立刻启动服务： 12sudo systemctl enable headscale.servicesudo systemctl start headscale.service 此时，协调服务器部署完毕。 安装Caddy反代既然我们要在公网上开放端口，反代的重要性就不再赘述了。虽然我之前是坚定的nginx党，但是在接触Caddy之后还是很快就屈服了。和nginx繁琐的配置文件相比，Caddyfile实在是太方便了。并且还有无感SSL等功能，实在是一个节约生命的选择。 安装流程参照官网流程： 123456sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curlcurl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#x27; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpgcurl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#x27; | sudo tee /etc/apt/sources.list.d/caddy-stable.listsudo apt updatesudo apt install caddysudo systemctl start caddy Caddy服务使用的Caddyfile路径是/etc/caddy/Caddyfile，每次更新Caddyfile之后，通过sudo systemctl reload caddy即可套用最新配置。 首先进行协调服务器的Caddyfile设置，其中8080是上述headscale配置文件中设置的监听地址，@ws代表允许websocket升级： 1sudo vim /etc/caddy/Caddyfile 123456789your.domain.com:port &#123; @ws &#123; header Connection *Upgrade* header Upgrade websocket &#125; reverse_proxy http://127.0.0.1:8080 reverse_proxy @ws http://127.0.0.1:8080&#125; 12# 更新最新配置sudo systemctl reload caddy Caddyfile的扩充内容将在下面的流程中进行说明。 安装协调服务器控制面板虽然可以通过Shell进行所有操作，但是在一个可视化的网页上进行诸如浏览用户、查看设备、添加设备等功能显然是更加方便的。不过，安装一个前端UI显然会有更多的风险，具体就看如何权衡了。 我使用的是gurucomputing&#x2F;headscale-ui框架，简洁轻量，功能足够，整体用起来感觉还行。 我们设UI的部署路径为/var/www/tailscale： 123mkdir /var/www/tailscalewget https://github.com/gurucomputing/headscale-ui/releases/download/2023.01.30-beta-1/headscale-ui.zip unzip -d /var/www/tailscale headscale-ui.zip 此时，应存在/var/www/tailscale/web/index.html。 接着在Caddyfile中配置控制面板的反代： 1234567891011121314your.domain.com:port &#123; @ws &#123; header Connection *Upgrade* header Upgrade websocket &#125; reverse_proxy http://127.0.0.1:8080 reverse_proxy @ws http://127.0.0.1:8080 handle /web* &#123; root /web* /var/www/tailscale file_server &#125;&#125; 因为此前端框架是静态的，所以通过一个handle段添加一个文件服务器即可。 然后就可以通过https://your.domain.com:port/web来访问你的前端框架了，前端框架是静态的，所以需要申请一个协调服务器管理密钥来进行连接，这个密钥不会保存在服务器上，需要手动管理。 1234# 创建了一个30天有效期的密钥headscale apikeys create --expiration 30d# 查看密钥情况headscale apikeys list 获取密钥后，在设置中的Heascale API Key进行配置。如果一切正常，则会显示绿色成功标识。 部署本地中转服务器相对于官方提供的若干中转服务器，显然是我们自己的机器延迟比较低一些。这关乎当NAT穿透失败退化到中转连接时我们的延迟，所以还是值得手动部署一下的。 中转服务器需要手动编译，我们需要安装GoLang： 12345678910# 如有更高版本需求请自行替换地址wget https://go.dev/dl/go1.21.6.linux-amd64.tar.gz# 清空旧版本rm -rf /usr/local/go# 解压tar -C /usr/local -xzf go1.21.6.linux-amd64.tar.gz# 添加到环境变量echo &quot;export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin&quot; &gt;&gt; /etc/profilesource /etc/profilego version 部署代码并编译： 123456# GoLang启用模块, 历史包袱真烦人go env -w GO111MODULE=on# 设置cn镜像站go env -w GOPROXY=https://goproxy.cn,direct# 拉取代码并编译go install tailscale.com/cmd/derper@main 此时derper可执行文件在$HOME/go/bin下，阿里云环境下就是/root/go/bin/derper 添加daemon并开机启动： 1sudo vim /etc/systemd/system/derp.service 1234567891011[Unit]Description=DerperAfter=network.targetWants=network.target[Service]User=rootRestart=alwaysExecStart=/root/go/bin/derper -hostname your.domain.com -a :8081 -stun-port STUNPORT --verify-clientsRestartPreventExitStatus=1[Install]WantedBy=multi-user.target 12sudo systemctl enable derp.service sudo systemctl start derp.service 记得替换其中的域名stunport，端口可以随意设置，只要不和其他程序冲突即可。记得在阿里云控制台中放行这几个端口，并且在之后的derp声明文件中填写正确的端口。:8081代表只允许本机地址连接，外部链接需要通过反代。derpport则只需要在反代处设置即可。 123# 创建derp声明文件mkdir /var/www/tailscale/derpvim /var/www/tailscale/derp/derp.json 123456789101112131415161718&#123; &quot;Regions&quot;: &#123; &quot;901&quot;: &#123; &quot;RegionID&quot;: 901, &quot;RegionCode&quot;: &quot;Server901&quot;, &quot;RegionName&quot;: &quot;Server901&quot;, &quot;Nodes&quot;: [ &#123; &quot;Name&quot;: &quot;901a&quot;, &quot;RegionID&quot;: 901, &quot;STUNPort&quot;: STUNPORT, &quot;DERPPort&quot;: DERPPORT, &quot;HostName&quot;: &quot;your.domain.com&quot; &#125; ] &#125; &#125;&#125; 接着编辑Caddyfile并重载caddy配置： 1234567891011121314151617181920212223242526272829your.domain.com:port &#123; @ws &#123; header Connection *Upgrade* header Upgrade websocket &#125; reverse_proxy http://127.0.0.1:8080 reverse_proxy @ws http://127.0.0.1:8080 handle /web* &#123; root /web* /var/www/tailscale file_server &#125; handle /derp* &#123; root /derp* /var/www/tailscale file_server &#125;&#125;your.domain.com:DERPPORT &#123; @ws &#123; header Connection *Upgrade* header Upgrade websocket &#125; reverse_proxy http://127.0.0.1:8081 reverse_proxy @ws http://127.0.0.1:8081&#125; 此时你的https://your.domain.com:port/derp/derp.json应该可以访问了。并且浏览器直接访问https://your.domain.com:DERPPORT会显示一个大大的DERP。至此，本地中转服务器部署完成。 将协调服务器的机器添加至内网我们在刚才的中转服务器启动项中设置了--verify-clients，也就是只允许在网络中的机器才可以连接本DERP。所以我们需要把协调服务器和中转服务器所在的机器加入内网才可以。 1234# 安装tailscale客户端curl -fsSL https://tailscale.com/install.sh | sh# 连接到我们的协调服务器tailscale up --login-server=https://your.domain.com:port 此时会显示一个登录网址，复制其中的nodekey:xxxxxxxxxx部分，在前端控制面板中添加一个用户，把此设备添加到用户的网络内。之后Shell中会显示Success，此时协调服务器所在的机器就被添加到内网了。 其他设备（Windows、Linux、Android、iOS等）连接Tailscale的方法各有不同，可以自行谷歌。唯一需要手动操作的就是指定--login-server。 Tailscale杂项本地路由如果我在外网，想要访问路由器的192.168.1.0/24网段，那么就需要让一个在内网的设备提供本地路由。有设置出口节点和使用网段路由两种方法。 出口节点1234567891011121314151617181920212223242526# 启用IP转发, 否则可能会无法通过出口## 系统中存在/etc/sysctl.d路径echo &#x27;net.ipv4.ip_forward = 1&#x27; | sudo tee -a /etc/sysctl.d/99-tailscale.confecho &#x27;net.ipv6.conf.all.forwarding = 1&#x27; | sudo tee -a /etc/sysctl.d/99-tailscale.confsudo sysctl -p /etc/sysctl.d/99-tailscale.conf## 否则echo &#x27;net.ipv4.ip_forward = 1&#x27; | sudo tee -a /etc/sysctl.confecho &#x27;net.ipv6.conf.all.forwarding = 1&#x27; | sudo tee -a /etc/sysctl.confsudo sysctl -p /etc/sysctl.conf# 声明本设备提供出口节点## 已经登录的设备tailscale set --advertise-exit-node## 未登录的设备tailscale up --login-server=https://your.domain.com:port --advertise-exit-node# 在headscale协调服务器端启用出口节点headscale routes list# 启用对应的ID, 通常有IPv4和v6两个headscale routes enable -r IDheadscale routes enable -r ID# 此时在节点状态中可以看到该节点提供出口tailscale status 不同的tailscale客户端有不同的出口设置方法，将出口节点设置后，本地所有的网络请求都会流经出口节点访问。此时就可以访问本地路由了。 网段路由有些特殊的网段不会流经出口节点，此时就需要手动指定路由网段。 123456789101112# 声明本设备提供路由## 已经登录的设备tailscale set --advertise-routes=192.168.1.0/24## 未登录的设备tailscale up --login-server=https://your.domain.com:port -advertise-routes=192.168.1.0/24# 在headscale协调服务器端启用出口节点headscale routes list# 启用对应的ID, 通常有IPv4和v6两个headscale routes enable -r IDheadscale routes enable -r ID 网段路由在协调服务器启用后，和出口节点相反，其他节点不需要单独设置，默认所有的节点都会首先尝试流经路由访问该地址。如果不需要使用该网段的路由，则需要在相应的tailscale客户端进行设置。 阿里云机器内网DNS问题启用tailscale后，因为网段冲突，该机器会无法使用阿里云机器的内网访问apt镜像等。可以通过一系列的设置来将DNS设置回去，但本文选择简单粗暴的——换源。 对他使用清华大学镜像站吧。 12sudo mv /etc/apt/source.list /etc/apt/source.list.baksudo vim /etc/apt/source.list 1234567891011121314# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse# 预发布软件源，不建议启用deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse 1sudo apt update &amp;&amp; sudo apt upgrade 享受内网吧！ 上层设施集中服务到物理机器搞了一台EQ12迷你主机作为本地网络常驻设备，之前在各个阿里云轻量服务器上的内容也全部都迁移到了本地，然后再挨个反代出去（圣Docker）。 NAS体验搞了一台绿联NAS作为家庭存储，并配合docker安装auto_bangumi和qbittorrent搭建了自动追番解决方案（之后的文章再详谈！我还能再水一篇！） Sunshine-Moonlight远程桌面由于RDP没有办法控制手柄，所以如果想要玩游戏的话还是要借助Sunshine这种推流式的远程桌面。 无头远程桌面解决方案：小米智能插座+BIOS通电开机，通过EQ12提供的本地路由连接到台式电脑，RDP连入桌面启动Sunshine推流服务，Moonlight连接Sunshine。 收尾终于写完了！这篇文章在二月份就开始起草了，但是过年忙着和朋友们打牌（？），过完年上班又是忙中忙。还好，没有断更就是胜利。"},{"title":"Hexo迁移小结","path":"2024/01/summary-hexo-migration/","text":"转眼间又很久很久很久（三年）没有管博客了，为了不再荒废，痛定思痛，把博客迁移到了Hexo。 这么多年过去了，博客也是转来转去折腾了好几次了。从一开始的Wordpress到静态博客，从Gridea到现在的Hexo。俺寻思，好久不写博客一定是因为Gridea的图形界面不好用（心虚）！另外，Gridea把各种密钥也一起放在了配置、文章目录下，使得前端和后端的仓库必须分离而且保持private，实在不方便我这种很多台设备不断切换的玩法。所以，把整个博客迁移到了Hexo。 为了庆祝迁移完工，也是给恢复更新开个头，简单记录一下这次的折腾过程。 安装和配置Hexo安装Hexo其实挺傻瓜式的，基本按着官方教程走下来就ok了。 123456HEXO_PATH=~/Applications/Hexomkdir $HEXO_PATH &amp;&amp; cd $HEXO_PATHnpm install -g hexo-clihexo initnpm install 就万事大吉了，就非常的傻瓜式。 接下来就是配置一下_config.yml和package.json了，根据需求照着改就OK。我的一些自定义： 1234567891011121314151617181920212223242526272829# 为了让_post文件夹内用于分类的子文件夹不影响URL的生成, 换成了:namepermalink: &#x27;:year/:month/:name/&#x27;# 想了下, Github Page在国内某些运营商网络下可能比较慢, 所以镜像了Gitee Page# 这就需要生成相对路径而不是绝对路径relative_link: true# 和主题配合设置代码高亮syntax_highlighter: highlight.jshighlight: line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: trueprismjs: preprocess: true line_number: true tab_replace: &#x27;&#x27;# 部署相关配置deploy:- type: git repo: https://github.com/DCTewi/dctewi.github.io branch: hexo message: &#x27;[update] hexo updated at &#123;&#123; now(&#x27;&#x27;yyyy-MM-dd HH:mm:ss&#x27;&#x27;) &#125;&#125;&#x27;- type: git repo: https://gitee.com/dctewi/dctewi.gitee.io branch: hexo-mirror 配置好之后直接hexo clean &amp;&amp; hexo g &amp;&amp; hexo s --debug就可以在本地4000端口预览了。 更换主题、配置插件原版主题有种2016年Wordpress默认主题的味道，在主题商店翻了半天，找到了这个叫做NexMoe的主题，感觉还不错。 依旧是傻瓜式安装： 123npm install hexo-theme-nexmoe hexo-renderer-infernohexo config theme nexmoehexo g &amp;&amp; hexo s 进行一次hexo gen之后，会在根目录生成一个_config.nexmoe.yml，这就是主题的配置文件了。这个主题的配置还挺多的，配置了半天。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 直接使用了source/images/下的文件，毕竟都上传到Github了，什么图床也没有本地靠谱avatar: /images/avatar.png # 网站 Logo# 使用jsdelivr的开源CDN功能缓存文章内的图片imageCDN: # 图片 CDN 功能 enable: true # 开启该功能 # 查看源码发现这里其实是一个在文章渲染后进行全局匹配的正则 # 使用前向匹配来避免匹配到不应该匹配的东西 # 比如默认的../../images就会把非img标签内的字符串匹配掉 # 这样，md内的![]()图片就会被替换到cdn去，达到编辑时和部署后的路径同步 origin: (?&lt;=&lt;img.*?src=&quot;)../../images/ to: https://cdn.jsdelivr.net/gh/DCTewi/dctewi.github.io@hexo/images/# 在文章底部添加MathJax来提供Latex支持slotFooter: | &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mathjax@latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; &lt;script&gt;MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ [&#x27;$&#x27;,&#x27;$&#x27;], [&quot;\\\\(&quot;,&quot;\\\\)&quot;] ], processEscapes: true, skipTags: [&#x27;script&#x27;, &#x27;noscript&#x27;, &#x27;style&#x27;, &#x27;textarea&#x27;, &#x27;pre&#x27;, &#x27;code&#x27;] &#125; &#125;); MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += &#x27; has-jax&#x27;; &#125; &#125;);&lt;/script&gt;# Giscus配置slotComment: | &lt;script src=&quot;https://giscus.app/client.js&quot; data-repo=&quot;DCTewi/dctewi.github.io&quot; data-repo-id=&quot;你的Giscus配置&quot; data-category=&quot;Giscus&quot; data-category-id=&quot;你的Giscus配置&quot; data-mapping=&quot;pathname&quot; data-strict=&quot;0&quot; data-reactions-enabled=&quot;1&quot; data-emit-metadata=&quot;0&quot; data-input-position=&quot;top&quot; data-theme=&quot;noborder_light&quot; data-lang=&quot;zh-CN&quot; crossorigin=&quot;anonymous&quot; async&gt; &lt;/script&gt; 之后把所需要的几个插件安装一下： 1234npm install hexo-generator-feednpm install hexo-generator-json-contentnpm install hexo-generator-sitemapnpm install hexo-word-counter 并且在_config.yml中进行配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# hexo-generator-feedfeed: enable: true type: atom path: atom.xml limit: 20 hub: null content: null content_limit: 140 content_limit_delim: &#x27; &#x27; order_by: &#x27;-date&#x27; icon: icon.png autodiscovery: true template: null# hexo-generator-json-contentjsonContent: meta: false pages: false posts: title: true date: false path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false# hexo-word-countersymbols_count_time: symbols: true time: true total_symbols: false total_time: false exclude_codeblock: true awl: 4 wpm: 275 suffix: &#x27;&#x27;# hexo-generator-sitemapsitemap: path: sitemap.xml # template: ./sitemap_template.xml rel: true tags: false categories: false 到这里就大功告成了，剩下的就是迁移内容。因为都是Markdown，只需要把两个博客框架的front-matters统一一下就可以直接使用了。整体把文章移过去，收拾了一下关于、友链等几个页面，博客终于焕然一新了。之后最重要的还是保持更新吧，经常写点博客也确实是个好习惯。 其他的一些配置配置Giscus按照官网配下来就可以，本地配置在上方有写。 友链增强原版主题其实就带友情链接的模板，但是是静态随机的。简单的搞了下动态随机。 12345678910111213141516&lt;!--https://github.com/DCTewi/dctewi.github.io/blob/hexo-backend/source/friends.md?plain=1--&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 这里注入了一个Fisher–Yates Shuffle算法用来洗牌jQuery.prototype.shuffle = function () &#123; var res = this; for (var i = res.length - 1; i &gt;= 0; i--) &#123; var rnd = Math.floor(Math.random() * (i + 1)); var ind = res[rnd]; res[rnd] = res[i]; res[i] = ind; &#125; return res;&#125;// 打乱一下顺序var items = $(&quot;.nexmoe-py &gt; ul &gt; li&quot;).shuffle(); $(&quot;.nexmoe-py &gt; ul&quot;).empty().append(items);&lt;/script&gt;"},{"title":"【杂谈】重振旗鼓","path":"2022/03/blog-reboot/","text":"咕着咕着，已经两年没有写过新博客了（草）。生活方面、技术方面和其他的种种方面都发生了翻天覆地的变化，是时候重新把博客拿起来了。 路过图床的事故之后，我自己搭了一个图床。但友情链接里的图还没有搬过去，凑空把友链里的图恢复一下。 另外，我已经光荣退役了（），所以博客的内容应该会从竞赛转向日常开发和一些碎碎念。自我介绍的部分以及目标页面都该返厂，过两天重新放出来。 大概就这样吧。不管怎样，多写点东西总不是什么坏习惯。"},{"title":"【笔记】在 Blazor WebAssembly Hosted 中使用 Identity","path":"2020/12/blazor-webassembly-hosted-with-identity/","text":"记录了一些 Blazor WebAssembly 的基础知识和在其中使用 Identity 进行身份验证的知识点。好久不写博客了，手都生了。 注：本文中使用的 .NET 版本为 .NET 5.0（.NET Core 和 .NET Framework 合并的版本） 什么是 WebAssembly顾名思义，WebAssembly（wasm）是一种实验性的 Web 低级编程语言，应用于浏览器的客户端，以提供比 JavaScript 更快速的便宜和运行。并允许开发者将自己喜欢的编程语言编译成 wasm 后在客户浏览器内以接近原生的性能运行。打破前端只有 JavaScript 的桎梏，让各种“后端”语言走上前台，走进用户的浏览器。 WebAssembly 由 W3C 发起，由 Mozilla，Google，Microsoft，Apple 分别代表四大浏览器牵头，从2017年起开始实验性支持。最终在 2019 年 12 月被 W3C 推荐，成为 Web 的第四种语言。 什么是 BlazorBlazor 是 .NET 社区的 Web 应用解决方案，名字取自 Browser + Razor 之意，以 C# 和 HTML 创建 Web 应用。 Blazor 分为 Blazor Server 和 Blazor WebAssembly。Blazor Server 指托管于 Asp.Net Core 的服务器上的瘦客户端。绝大多数操作在服务器端进行，客户端指挥下载所需要的最小化的页面，并通过 SignalR 的连接更新浏览器中的界面。Blazor WebAssembly 是基于 wasm 的单页应用。初始加载内容远大于 Blazor Server，但之后的处理过程将在客户端硬件内完成，所以它具有更快的响应速度。 Blazor WebAssembly Hosted 是 Blazor WebAssembly with Asp.Net Core Hosted 架构的简称。他是由交给客户的 Blazor WebAssembly 作为前端应用，同时后端由 Asp.Net Core Api 进行数据交换的一种结构。 使用 Identity 进行身份验证新建项目.NET 官方推荐的身份验证方法是通过 Microsoft.AspNetCore.Identity 和 Identity Server 4 配合 Jwt 来进行用户身份的验证。 新建工程时，将身份验证和 Asp.Net Core Hosted 正确配置： 重建数据库上下文等待示例工程创建完毕之后，可以看到 Solution 中被分成了三个项目。分别是盛放 Blazor WebAssembly 的 Client 项目，盛放 Asp.Net Core 服务器的 Server 项目以及两个项目之间互相通信的共享项目 Shared。 其中，Server 项目中已经写好了默认的用户类、数据库上下文类以及数据库初始化 Migration。默认情况下，Entity Framewok Core 使用的数据库是 SQL Server LocalDB。虽然我更偏好 SQLite，但其实只是换一个 NuGet 包和连接字符串的事，所以等到下次杂项的时候在提，这次先用 LocalDB 凑合。 删除Server/Data/Migrations文件夹，在选中 Server 项目的情况下打开 工具 - NuGet 包管理器 - 程序包管理器控制台（或使用 Ctrl + &#96;打开），使用以下指令重新建立 Migration 和数据库： 12Add-Migration InitCreate -o Data/MigrationsUpdate-Database 或者，如果你使用的是 .NET Core CLI： 12dotnet ef migrations add InitCreate -o Data/Migrationsdotnet ef database update 通过基架创建 Identity 所需的 Remote Pages如果不创建基架，Identity 模块的 &lt;RemoteAuthenticatorView&gt; 控件连接到的界面都会使用默认的页面。通过基架将所有的页面创建后，就可以通过修改cshtml文件来对逻辑和界面进行自定义。 从 Server 项目的新建菜单中新建基架项目，选择 Identity 并指定数据库上下文类，接着替换全部（不得不说巨硬的这个机翻属实不行，Identity 都能翻译成标识）。 使用基于 Role 的身份验证基于默认设置，Jwt 口令中是没有 Role 相关信息的。我们需要让服务器发出的 Jwt 口令中带上 Role 信息： 123456789101112131415161718/// Server/Startup.cs/// Startup.ConfigureServices(IServiceCollection)services.AddDefaultIdentity&lt;ApplicationUser&gt;() .AddRoles&lt;IdentityRole&gt;() // 指定Role的类 .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();services.AddIdentityServer(options =&gt; options.IssuerUri = Configuration.GetValue&lt;string&gt;(Literal.Domain)) // 在JWT中添加Role信息 .AddApiAuthorization&lt;AppUser, ApplicationDbContext&gt;(options =&gt; &#123; options.IdentityResources[&quot;openid&quot;].UserClaims.Add(&quot;role&quot;); options.ApiResources.Single().UserClaims.Add(&quot;role&quot;); &#125;);JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Remove(&quot;role&quot;);services.AddAuthentication() .AddIdentityServerJwt(); 坑爹的一点是，当用户只有一个 Role 的时候，Claims 中的信息为： 123&#123; &quot;role&quot;: &quot;Admin&quot;&#125; 当用户有不止一个 Role 的时候，Claims 中的信息为： 123&#123; &quot;role&quot;: [&quot;Admin&quot;, &quot;Operator&quot;]&#125; 但！我们亲爱的 Blazor 端的 ClaimsPrincipal.IsInRole()函数和[Authorize(Roles = &quot;&quot;)]属性以及&lt;AuthorizeView Roles=&quot;&quot;&gt;控件都是通过直接判断字符串是否相等来判断用户是否在 Role 内。 我暴怒，这个问题困扰了我好几天的时间。但在 Github Issue 中，Blazor 的 Contributor 竟然说这是 a Feature ！ 对此，我们需要手动 Hack 一下客户端内的 AccountClaimsPrincipalFactory，创建如下子类： 12345678910111213141516171819202122232425262728/// Client.Service.RolesAccountClaimsPrincipalFactory.cspublic class RolesAccountClaimsPrincipalFactory : AccountClaimsPrincipalFactory&lt;RemoteUserAccount&gt;&#123; public RolesAccountClaimsPrincipalFactory(IAccessTokenProviderAccessor accessor) : base(accessor) &#123; &#125; public override ValueTask&lt;ClaimsPrincipal&gt; CreateUserAsync(RemoteUserAccount account, RemoteAuthenticationUserOptions options) &#123; // 提取 var roles = account?.AdditionalProperties[&quot;role&quot;] as JsonElement?; // 是数组的情况，分割 if (roles?.ValueKind == JsonValueKind.Array) &#123; account.AdditionalProperties.Remove(&quot;role&quot;); var claimsPrincipal = base.CreateUserAsync(account, options).Result; foreach (var ele in roles.Value.EnumerateArray()) &#123; (claimsPrincipal.Identity as ClaimsIdentity) .AddClaim(new Claim(&quot;role&quot;, ele.GetString())); &#125; return new ValueTask&lt;ClaimsPrincipal&gt;(claimsPrincipal); &#125; // 返回给基类处理 return base.CreateUserAsync(account, options); &#125;&#125; 并在 Client 端的 Program.cs 注册中间件： 123456/// Client/Program.cs/// Program.Mainbuilder.Services.AddScoped(typeof(AccountClaimsPrincipalFactory&lt;RemoteUserAccount&gt;), typeof(RolesAccountClaimsPrincipalFactory));builder.Services.AddApiAuthorization(); 只能说，希望这个 Feature 能早日被定性成 Bug。 自定义然后就是自由发挥的时刻了。 通过中间件自定义账户规则： 1234567891011121314151617/// Server/Startup.cs/// Startup.ConfigureServices(IServiceCollection)services .AddDefaultIdentity&lt;ApplicationUser&gt;(options =&gt; &#123; options.SignIn.RequireConfirmedAccount = false; options.Password.RequiredLength = 6; options.Password.RequiredUniqueChars = 2; options.Password.RequireNonAlphanumeric = false; options.User.AllowedUserNameCharacters = string.Empty; options.User.RequireUniqueEmail = true; &#125;) .AddUserValidator&lt;UserNameValidator&lt;ApplicationUser&gt;&gt;() .AddRoles&lt;IdentityRole&gt;() .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;(); 自定义登录加载页面（通过提供 Render Fragment 参数）： 123456789101112131415161718192021222324252627282930313233343536373839/// Client/Pages/Authentication.razor@page &quot;/authentication/&#123;Action&#125;&quot;@using Microsoft.AspNetCore.Components.WebAssembly.Authentication&lt;RemoteAuthenticatorView Action=&quot;@Action&quot; &gt; &lt;CompletingLoggingIn&gt; &lt;Loading LoadingMessage=&quot;@LocalStrings.LoadMessage.CompletingLogin&quot;&gt;&lt;/Loading&gt; &lt;/CompletingLoggingIn&gt; &lt;CompletingLogOut&gt; &lt;Loading LoadingMessage=&quot;@LocalStrings.LoadMessage.CompletingLogout&quot;&gt;&lt;/Loading&gt; &lt;/CompletingLogOut&gt; &lt;LoggingIn&gt; &lt;Loading LoadingMessage=&quot;@LocalStrings.LoadMessage.LoggingIn&quot;&gt;&lt;/Loading&gt; &lt;/LoggingIn&gt; &lt;LogInFailed&gt; &lt;ErrorComponent ErrorTitle=&quot;@LocalStrings.Error.BadRequest400&quot; ErrorContent=&quot;@LocalStrings.Error.LoginFailed&quot;&gt;&lt;/ErrorComponent&gt; &lt;/LogInFailed&gt; &lt;LogOut&gt; &lt;Loading LoadingMessage=&quot;@LocalStrings.LoadMessage.LogOut&quot;&gt;&lt;/Loading&gt; &lt;/LogOut&gt; &lt;LogOutFailed&gt; &lt;ErrorComponent ErrorTitle=&quot;@LocalStrings.Error.BadRequest400&quot; ErrorContent=&quot;@LocalStrings.Error.LogOutFailed&quot;&gt;&lt;/ErrorComponent&gt; &lt;/LogOutFailed&gt; &lt;LogOutSucceeded&gt; &lt;RedirectToHome&gt;&lt;/RedirectToHome&gt; &lt;/LogOutSucceeded&gt; &lt;Registering&gt; &lt;Loading LoadingMessage=&quot;@LocalStrings.LoadMessage.Registering&quot;&gt;&lt;/Loading&gt; &lt;/Registering&gt; &lt;UserProfile&gt; &lt;Loading LoadingMessage=&quot;@LocalStrings.LoadMessage.LoadingUserProfile&quot;&gt;&lt;/Loading&gt; &lt;/UserProfile&gt;&lt;/RemoteAuthenticatorView&gt;@code&#123; [Parameter] public string Action &#123; get; set; &#125;&#125; 参考资料 WebAssembly | MDN (mozilla.org) Blazor | Build client web apps with C# | .NET (microsoft.com) [Blazor][Wasm] Using roles with ApiAuthorization + Blazor · Issue #17649 · dotnet&#x2F;AspNetCore.Docs (github.com)"},{"title":"【总结】我的 Unity C# 编码规范","path":"2020/09/my-unity-csharp-code-standard/","text":"好久没水文章了。所以在这个考试过去了一半了的时间里发点东西，算是起个头，之后又要肝起来咯。 本套编码规范只代表个人习惯，符合习惯的规范就是好规范。有观点欢迎讨论，但谢绝人身攻击哦。 命名 不使用匈牙利命名法，不在变量前添加m_等前缀。 使用大驼峰命名属性、方法、事件、枚举、类型和命名空间。 12345678910public class MyClass&#123; public event Action SomeEvent; public int Name &#123; get; set; &#125; [MenuItem(&quot;Window/SomeMenu&quot;)] public void DoSomething() &#123; &#125;&#125; 使用大驼峰命名静态变量，常量，和**公开字段(包括公开只读字段)**。 使用小驼峰命名私有字段，临时变量，参数，不应&#x2F;不能被其他对象访问的私有字段应添加一个下划线前缀。 布尔变量由小写介词短语开头，表示逻辑类型。 123456789public static string AssetPath = &quot;Asset/&quot;;public const double Pi = 3.1415926;public readonly int PhoneNumber = 123456;public string Name = &quot;Hanpi&quot;;private int _health;public bool isOnline;private bool canPlayGame; 接口名以大写I作为前缀。 123public interface IManager&#123;&#125; 类名应该是名词或者名词性短语。 方法名应该是动宾&#x2F;介宾短语。 局部变量的名称要有意义，慎用简写&#x2F;缩写。 12345678public class GameManager&#123; public string GetName() &#123; var tempVar = MakeName(); return tempVar; &#125;&#125; 结构类型成员的排列顺序自上而下依次为： 静态：静态字段，静态属性，静态方法； 字段：私有字段，受保护字段（尽量不要使用公开字段）； 属性：私有属性，受保护属性，公开属性； 事件：私有事件，受保护事件，公开事件； 嵌套枚举，嵌套类； 构造函数（如果有），按参数数量升序排列； 重载方法（如果有），按需排列； 方法，按需排列； Unity 保留方法（如Update()），按调用时间前后排序； 注1：如有需要，应该使用partial将一部分放在ClassName.PartialType.cs文件中。比如玩家的不同状态机类。 注2：如果文件行数较多，则应该使用#region分开代码块并折叠。 格式缩进 不使用 Tab 字符，使用四个空格字符控制一个缩进。 括号 左大括号总是在开始块的语句下一行的行首，块内容应再缩进四个空格。 1234if (condition)&#123; DoSth();&#125; Switch-Case 语句的缩进方法： 123456789switch (s)&#123; case 0: &#123; DoSth(); &#125; break; default: break;&#125; 单行语句中，可以有在同一行开始或结束的括号。 123456789public class Foo&#123; int bar; public int Bar &#123; get &#123; return bar; &#125; set &#123; bar = value; &#125; &#125;&#125; 空格 函数参数之间逗号后使用单个空格。 12Right: Console.In.Read(myChar, 0, 1);Wrong: Console.In.Read(myChar,0,1); 圆括号和参数后面不能使用空格。 12Right: CreateFoo(myChar, 0, 1)Wrong: CreateFoo( myChar, 0, 1 ) 函数名称和括号之间不能使用空格。 12Right: CreateFoo()Wrong: CreateFoo () 不要在括号内使用空格。 12Right: x = dataArray[index];Wrong: x = dataArray[ index ]; 在流程控制语句之前使用单个空格。 在算术运算符前后添加一个空格。 12Right: while (x == y)Wrong: while(x==y) 注释 版权声明（若选择） 版权声明卸载文件头，不应该使用三斜杠注释，应该使用双斜杠注释。 12345//-----------------------------------------------------------------------// &lt;copyright file=&quot;ContainerControl.cs&quot; company=&quot;Microsoft&quot;&gt;// Copyright (c) Microsoft Corporation. All rights reserved.// &lt;/copyright&gt;//----------------------------------------------------------------------- 方法注释 方法注释应该使用三斜杠XML文档注释。对于开发者互相的评论，应该使用&lt;devdoc&gt;标签。 &lt;summary&gt;标签格式应该为：xxx of/which/about/... something。 12345678public class Foo &#123;/// &lt;summary&gt;Public stuff about the method&lt;/summary&gt;/// &lt;param name=”bar”&gt;What a neat parameter!&lt;/param&gt;/// &lt;devdoc&gt;Cool internal stuff!&lt;/devdoc&gt;///public void MyMethod(int bar) &#123; … &#125;&#125; 代码注释 使用双斜杠注释。注释应放在代码的上方。 12// I&#x27;m a comment.var rb = GetComponent&lt;RigidBody2D&gt;(); 命名空间命名空间应根据路径分配，脚本文件的命名空间在using语句下方空出一行处。 123456using System;namespace ProjectName.Core&#123; public class MyClass() &#123; &#125;&#125;"},{"title":"【算法】正逆康托展开基础","path":"2020/03/cantor-basic/","text":"康托展开和逆康托展开是全排列和他的字典序序号相互转化的两种算法。在有关排列方案的问题中可以作为枚举的哈希函数，在允许枚举的数据范围内具有优良的复杂度。但是一般允许枚举的数据范围大概是20以内，因为21！爆int64，所以这也是种图一乐算法。 算法作用在$O(n^2)$复杂度中得到一个序列在他的全排列中的字典序序号。逆展开则是由一个全排列中的字典序序号快速得到序列。由树状数组优化后复杂度可以达到$O(n\\log n)$ 实现思路康托展开对于一个长度为$n$的序列，若他的第$i$位是当前可用数字集合中的第$j$小的数，则说明他经过这一位比这一位的最小可能字典序大了$j\\cdot i!$。从左到右依次计算并更新可用数字的集合即可。 例如，对于${1, 2, 3}$的全排列，有表格： 排列 序号 展开 每位的可用数集 1, 2, 3 1 0 * 2! + 0 * 1! + 0 * 0! 123, 23, 3 1, 3, 2 2 0 * 2! + 1 * 1! + 0 * 0! 123, 23, 2 2, 1, 3 3 1 * 2! + 0 * 1! + 0 * 0! 123, 13, 3 2, 3, 1 4 1 * 2! + 1 * 1! + 0 * 0! 123, 13, 1 3, 1, 2 5 2 * 2! + 0 * 1! + 0 * 0! 123, 12, 2 3, 2, 1 6 2 * 2! + 1 * 1! + 0 * 0! 123, 12, 1 逆康托展开上述过程的逆运算即可。每次算出当前位是可用数集的第几位，获取并更新可用数集即可。 具体实现一种可能的实现方法： 12345678910111213141516171819202122232425262728293031323334const int FACT[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; // 静态化阶乘值// 正康托展开long long cantor(const vector&lt;int&gt; &amp;a)&#123; long long res (0); int len (a.size()); for (int i = 0; i &lt; len; i++) &#123; int num = 0; for (int j = i + 1; j &lt; len; j++) &#123; if (a[j] &lt; a[i]) num++; &#125; res += FACT[len - i - 1] * num; &#125; return res;&#125;// 逆康托展开// \\param x 字典序序号// \\param n 排列长度vector&lt;int&gt; decantor(int x, int n)&#123; vector&lt;int&gt; vis, res; for (int i = 0; i &lt;= n; i++) vis.emplace_back(i + 1); for (int i = n - 1; i &gt;= 0; i--) &#123; int now = x / FACT[i]; x %= FACT[i]; res.emplace_back(vis[now]); vis.erase(vis.begin() + now); &#125; return res;&#125; 最后以上就是康托展开的基础内容了。 这种图一乐算法既能图一乐，还篇幅短小。真的很适合水博客（草）。"},{"title":"【算法】没啥用的判圈算法两则","path":"2020/03/cycle-detection/","text":"如题，这里记录了两则没啥用的判圈算法。 对于“判断有向图中是否存在环”这类问题，竞赛中常见的解决办法一般都是带标记深搜或者拓扑排序后删点，在邻接表或者前向星下这两种方法的时间复杂度都是线性，所以一般够用。 但最近在某个沙雕视频里了解到了一个奥妙算法，叫做 Floyd Cycle Detection，可以在线性时间，常数空间的条件下判断环是否存在。但是竞赛题没办法这么卡空间，了解下这算法也就图一乐。 Floyd Cycle Detection Floyd 判圈算法 (Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法 (Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。 如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以不同速度前进的 2 个指针必定会在某个时刻相遇。同时显然地，如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的 2 个指针最终相遇，那么可以判定存在一个环，且可以求出 2 者相遇处所在的环的起点与长度。 这是 Wikipedia 上的算法描述。简而言之，如果图有环，那么从图上某一点同时出发的速度不同的两个指针，一定会在快的指针比慢的指针多跑整数倍长度的某一时刻相遇。相反，如果快的点遍历完了图，那么则说明图上没有环。 Floyd 判圈的具体做法是令快指针每次走两步，慢指针每次走一步。两个指针相遇之后定住一个让另一个跑一圈就可以求出环长度了。 从慢指针到环上开始，慢指针最多只会走一圈两个指针就会相遇。所以时间复杂度是线性$O(m+n)$，即两个指针的步数和。只创建了两个指针和环长，所以空间复杂度是$O(1)$。 代码大概就这样（临时手搓，没有验证）： 123456789101112131415int floyd_cycle_detection(Node *head)&#123; Node *slow = head, *quik = head; int len = 1; while (1) &#123; if (quik == nullptr) return -1; if (slow == quik) break; slow = slow-&gt;next; quik = quik-&gt;next-&gt;next; &#125; while (slow-&gt;next != quik) slow = slow-&gt;next, len++; return len;&#125; Brent’s Cycle DetectionBrent’s Cycle Detection 算法是上边那个的优化，减少了常数，平均消耗时间减少了36%（据说）。 他和 Floyd 判圈的不同在于快指针每次的移动长度变成了$2^i$，慢指针不移动，而是若每次快节点移动的过程中两者没有相遇，则慢指针直接移动到快节点的位置。这样如果有环，快指针在最后一次移动过程中的步数就是环长度。若无环，则慢指针一直在“追逐”快指针，无法相遇。 也是挺好理解的，代码大概这样： 1234567891011121314151617int brent_cycle_detection(Node *head)&#123; Node *slow = head, *quik = head; int len = 0, now = 1; while (1) &#123; len++; quik = quik-&gt;next; if (quik == nullptr) return -1; if (slow == quik) return len; if (len &gt;= now) &#123; len = 0; now &lt;&lt;= 1; slow = quik; &#125; &#125;&#125; 最后虽然这俩算法可能没啥实战作用，但是某种意义上也能感受到一个学者应该拥有的那种对某个问题吹毛求疵的探索态度，值得我们学习。 但是这俩算法确实没啥用。 题外话： 彩虹社新专「SMASH The PAINT!!」太顶了，Sasaki的那首「煽動海獣ダイパンダ」过于清楚，ガチ了。"},{"title":"【总结】A*搜索算法小结","path":"2020/03/a-star/","text":"A* 搜索是一种使用了 Dijkstra 思想的启发式搜索，是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。把之前进行的总结整理了一下发了上来。 启发式搜索启发式搜索是搜索的主要优化方法之一，另一种常见的优化方法是记忆化搜索。 启发式搜索是一种在搜索的过程中，通过自定义估价函数$f(x)$对不同的子状态进行筛选、剪枝，从中选取更优解或者删去无效解的在线剪枝搜索。 例题：Luogu 1048 采药 当然，这道题是一道DP题，也是一道记忆化的题目。但是这道题也可以写成启发式搜索的形式：在取的时候判断是否超过了可行体积（可行性剪枝），不取的时候判断是否剩余药品的价值+当前价值&gt;当前解（最优性剪枝）。 上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e2 + 5;int n, m, ans;struct Node&#123; int time, value; double cost; bool operator&lt;(const Node &amp;o) const &#123; return cost &gt; o.cost; &#125;&#125; nodes[MAXN];// 估价函数：后方价值和int f(int t, int v)&#123; int res = 0; for (int i = 1; i + t &lt;= n; i++) &#123; if (v &gt;= nodes[t + i].time) &#123; v -= nodes[t + i].time; res += nodes[t + i].value; &#125; else return (int)(res + v * nodes[t + i].cost); &#125; return res;&#125;// 启发式搜索的动态剪枝void dfs(int t, int p, int v)&#123; ans = max(ans, v); if (t &gt; n) return; // 不选择 if (f(t, p) + v &gt; ans) dfs(t + 1, p, v); // 选择 if (nodes[t].time &lt;= p) dfs(t + 1, p - nodes[t].time, v + nodes[t].value);&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;nodes[i].time, &amp;nodes[i].value); nodes[i].cost = 1.0 * nodes[i].value / nodes[i].time; &#125; sort(nodes + 1, nodes + n + 1); dfs(1, m, 0); printf(&quot;%d\\n&quot;, ans); return 0;&#125; A*A Star 算法是 Dijkstra 和启发式搜索的结合。他的估价函数由两部分组成：$f(x)&#x3D;g(x)+h(x)$，其中$𝑔(𝑛)$表示从起点到任意顶点 $𝑛$ 的实际距离，$ℎ(𝑛)$ 表示任意顶点 $𝑛$ 到目标顶点的估算距离（根据所采用的评估函数的不同而变化）。 整体算法过程： Def Priority_Queue $Queue$ Do​ Let​ $u$ &#x3D;&gt; $u \\in Queue$ &amp;&amp; $f(u) &#x3D; min{f(x)\\ |\\ x\\in Queue}$ For Each $v$ &#x3D;&gt; $Exits(u\\to v)$ If $v \\notin Queue$ Then $Queue.Push(v)$, $Update(f(v))$ Else If $Cost(u\\to v) &lt; g(v)$ Then $Update(f(v))$ Until $Not\\ Queue.Empty()$ || $Target\\in Queue$ 他的整体过程可以概括为：每次从优先队 中取出一个$𝑓(𝑖)$最小的状态，然后更新可用的相邻状态，最大复杂度$O(n^2)$，优先队列优化后的期望复杂度为$O(nlogn)$。 因为启发式动态剪枝的存在，所以相对于一般的寻路算法，期望的搜索范围小。并且 A* 在$h(x)$满足三角形不等式时，不会将重复节点加入队列。 竞赛中的A*竞赛中的 A* 一般用来解决定点k短路的问题。即给出图，求两点之间第k条简单路。 我们预处理反向图中从终点出发的单源最短路作为$g(x)$，将从开始到当前状态走过的所有路径作为$h(x)$跑 A*。当我们第k次将终点入栈时，我们就找到了从起点到终点的第k短路。 例题：POJ 2449 Remmarguts’ Date 模板题，上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt; // POJ啥时候支持C++11啊我佛了using namespace std;typedef long long ll;const int MAXN = 1e3 + 5;const int MAXM = 1e5 + 5;const int MAXK = 1e3 + 5;const int INF = 1 &lt;&lt; 30;// 链式前向星, 正图反图两个头数组，边都在一个数组里struct Edge&#123; int v, w, next; Edge(int v = 0, int w = 0, int next = 0) : v(v), w(w), next(next) &#123; &#125;&#125; edge[MAXM &lt;&lt; 2];int headf[MAXN], headb[MAXN], edgecnt = 0; void addedge(int u, int v, int w)&#123; edge[++edgecnt] = Edge(v, w, headf[u]); headf[u] = edgecnt; // 正 edge[++edgecnt] = Edge(u, w, headb[v]); headb[v] = edgecnt; // 反&#125;int dis[MAXN], vis[MAXN], ans[MAXK]; // 反向最短路, 入队标记, 第i短路int n, m, s, t, k; // 见题意, n点m边从s到t的第k短路// 状态struct State&#123; int u, cost, sum; bool operator&lt;(const State &amp;o) const &#123; return sum == o.sum ? cost &gt; o.cost : sum &gt; o.sum; &#125; State(int u = 0, int g = 0) : u(u), cost(g) &#123; sum = g + dis[u]; &#125;&#125;;// A*本体void astar()&#123; if (dis[s] == INF) return; if (s == t) k++; int cnt = 0; priority_queue&lt;State&gt; q; q.push(State(s, 0)); while (q.size()) &#123; State e = q.top(); q.pop(); if (e.u == t) // 检查抵达终点次数 &#123; ans[++cnt] = e.cost; if (cnt == k) return; &#125; for (int i = headf[e.u]; i; i = edge[i].next) &#123; q.push(State(edge[i].v, e.cost + edge[i].w)); &#125; &#125;&#125;// SPFA求反图最短路void spfa()&#123; queue&lt;int&gt; q; q.push(t); vis[t] = 1; dis[t] = 0; while (q.size()) &#123; int u = q.front(); q.pop(); for (int i = headb[u]; i; i = edge[i].next) &#123; int v = edge[i].v; if (dis[v] &gt; dis[u] + edge[i].w) &#123; dis[v] = dis[u] + edge[i].w; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125; vis[u] = 0; &#125;&#125;void init()&#123; memset(headb, 0, sizeof headb); memset(headf, 0, sizeof headf); memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); for (int i = 0; i &lt;= n; i++) dis[i] = INF; edgecnt = 0;&#125;int main()&#123; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; init(); for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;k); spfa(); astar(); printf(&quot;%d\\n&quot;, ans[k]); &#125;&#125; 开发中的A*A*因为有着效率高，路径权值高度可定义化等特点，在游戏开发时经常配合Navmesh等技术用作AI寻路。比如有名的 A Star Pathfinding Project 。 最后这次的内容比较简单，所以也没多少字可以水写，就只稍微总结了一些模板和代码。当然如果有所帮助就更好了。"},{"title":"【折腾】Gridea Enchant 总结","path":"2020/03/gridea-enchant/","text":"Gridea 是一个类似于 Hexo 的静态博客管理框架。看中了它的颜值，但相比于 Hexo，有些功能不够全面。所以凑今天进行了一波魔改，将过程记录了下来。 注：本文中所有的..路径指库/文档/Gridea路径。 友情链接换成 Gridea 之后，友链一直简单地在用生成的用 markdown 硬搓的 html&#x2F;js，不够优雅，而且更新链条比较长（编辑json -&gt; 跑py -&gt; 复制markdown），所以自己魔改了一波 Gridea 和主题。 首先在../themes/你的主题/config.json文件中的customConfig列表中添加一个新对象： 1234567891011121314&#123; &quot;name&quot;: &quot;friends&quot;, &quot;label&quot;: &quot;友链&quot;, &quot;group&quot;: &quot;友链&quot;, &quot;type&quot;: &quot;array&quot;, &quot;value&quot;: [], &quot;arrayItems&quot;: [ &#123; &quot;label&quot;: &quot;名称&quot;, &quot;name&quot;: &quot;siteName&quot;, &quot;type&quot;: &quot;input&quot;, &quot;value&quot;: &quot;&quot; &#125;, &#123; &quot;label&quot;: &quot;链接&quot;, &quot;name&quot;: &quot;siteLink&quot;, &quot;type&quot;: &quot;input&quot;, &quot;value&quot;: &quot;&quot; &#125;, &#123; &quot;label&quot;: &quot;Logo&quot;, &quot;name&quot;: &quot;siteLogo&quot;, &quot;type&quot;: &quot;input&quot;, &quot;value&quot;: &quot;&quot; &#125;, &#123; &quot;label&quot;: &quot;描述&quot;, &quot;name&quot;: &quot;description&quot;, &quot;type&quot;: &quot;textarea&quot;, &quot;value&quot;: &quot;&quot; &#125; ], &quot;note&quot;: &quot;&quot; &#125; 接着重启 Gridea，可以看到已经有了配置页。进行一波填写之后，进行接下来的操作。 将../templates/下的post.ejs复制一份，命名为你想要的地址，如links.ejs。接着进行一波编辑，将有关post的内容都删去，编辑一下页面名称，把正文的位置(一般都是&#123;&lt;%- post.content %&gt;&#125;)替换成友链内容，再随便加个洗牌，实例： 1234567891011121314151617181920212223242526272829303132333435&lt;div class=&quot;post-content yue flex flex-wrap&quot;&gt; &lt;% if (site.customConfig.friends) &#123; %&gt; &lt;% site.customConfig.friends.forEach(function(friend) &#123; %&gt; &lt;div class=&quot;friend-box&quot;&gt; &lt;img class=&quot;friend-avatar&quot; src=&quot;&lt;%= friend.siteLogo %&gt;&quot;&gt; &lt;div class=&quot;flink-info&quot;&gt; &lt;a href=&quot;&lt;%= friend.siteLink %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= friend.siteName %&gt;&lt;/a&gt; &lt;br/&gt; &lt;%= friend.description %&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;); %&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这里注入了一个Fisher–Yates Shuffle算法用来洗牌 jQuery.prototype.shuffle = function() &#123; var res = this; for (var i = res.length - 1; i &gt;= 0; i--) &#123; var rnd = Math.floor(Math.random() * (i + 1)); var ind = res[rnd]; res[rnd] = res[i]; res[i] = ind; &#125; return res; &#125; // 打乱一下顺序 var items = $(&quot;.friend-box&quot;).shuffle(); $(&quot;.post-content&quot;).empty().append(items); &lt;/script&gt; &lt;% &#125; %&gt; &lt;/div&gt; 在../themes/你的主题/assets/styles/main.less中加点样式和动画： 1234567891011121314151617181920212223.friend-box &#123; float: left; width: calc(50% - 20px); margin: 15px 10px; img.friend-avatar&#123; width: 70px; height: 70px; border-radius: 50% !important; float: left; margin:0 15px 0 0 !important; transition:0.5s; -webkit-transtion:1.5s; &#125; img.friend-avatar:hover&#123; transform:rotate(360deg); -webkit-transform:rotate(360deg); &#125; .flink-info&#123; height:70px; overflow: hidden; line-height: 24px; &#125;&#125; 就完事了，效果：https://blog.dctewi.com/links/ SEOGridea 的主题大都不在网页标题加 title，SEO真的爆炸。Google Analytics 天天发邮件，一般在../templates/post.ejs里加个参数就可以了： 123&lt;head&gt; &lt;%- include(&#x27;./includes/head&#x27;, &#123; siteTitle: `$&#123;post.title&#125; | $&#123;themeConfig.siteName&#125;` &#125;) %&gt;&lt;/head&gt; 百度提交和谷歌统计的 js 都放进../templates/includes/head.ejs合适位置就行了。 参考资料 三步创建 Gridea 友情链接页 - 林小沐 jQuery如何对div进行排序 - SegmentFault Flex 布局教程：语法篇 - 阮一峰的网络日志 最后没了，就这。 我的前端知识全是被逼出来的（悲）。"},{"title":"【总结】Unity Input System 使用简要","path":"2020/02/unity-new-input-system/","text":"有关 Unity 新输入系统 Input System 的一些简单介绍和基础总结。目前关于新输入系统的中文资料略少，在 Unity 官方文档中学习了一番之后，我将一些基本的知识记录了下来。 新输入系统 (Input System) 概述在 Unity 设计之初，并没有预见到现在如此丰富的平台和设备支持规模，所以一开始设计的输入系统 UnityEngine.Input 使用起来并不舒适，在多设备和多平台输入处理时显得力不从心且不够优雅，甚至连游戏中热插拔手柄这种操作都显得十分臃肿和复杂。Unity Tec 从 2016 年起开始逐步开发新一代输入系统 UnityEngine.InputSystem ，到今天（Unity 2019.3.0f6），已经迭代到了 1.0.0-preview.4 版本。官方表示大概在 Unity 2020 版本推出新输入系统的正式版，但是旧输入系统的下架时间并没有被明确说明。 新输入系统基于事件，输入设备和动作逻辑互相分离，通过配置映射来处理输入信息。具有易用，多设备多平台协调一致的特点。现在已经可以在 Package Manager 中安装使用了。 Input System 安装在 Unity 2019.1 之后的版本中，打开包管理器（Windows -&gt; Package Manager），在 Advanced 菜单中勾选预览版支持（Show Preview Packages），接着就可以在 All Packages 列表中找到 Input System 了，点击 Install 安装即可。 导入过程中会跳出警告窗口告知需要激活新输入系统的后端，点击是会重启编辑器，此时便启用了新输入系统。 接着打开 Edit -&gt; Project Settings，在 Player 选项页中的 Other Settings -&gt; Configuration 中设置 Active Input Handling 为 Input System 以禁用旧输入系统，以防止两个输入系统的冲突和杜绝隐患。 此时，你的工程中已经成功安装了新输入系统。 Input System 简单介绍有关新输入系统的内容几乎都在UnityEngine.InputSystem命名空间下，使用时不要忘记 using UnityEngine.InputSystem。一些特殊的对象可能在子命名空间下，具体请查阅文档。 Class InputAction这个类表示的是一种响应动作逻辑，可以绑定到多个物理输入上，这些绑定的物理输入和得到的输入值将影响同一个 Input Action 对象。该类只代表一种动作“逻辑”而不代表任何物理输入。 每个动作逻辑在每一时刻都有现在的状态阶段（Phase），通过 Enum InputActionPhase 表示，有五种阶段。分别为：Canceled, Disabled, Performed, Started, Waiting。在Start, Performed, Canceled 阶段会分别触发三个对应的 C# 事件（类型为event Action&lt;InputAction.CallbackContext&gt;）。 每次动作逻辑被触发时，可以通过ReadValue&lt;TValue&gt;()成员来获取本次触发的具体值。 声明： 1[Serializable] public sealed class InputAction : ICloneable, IDisposable Struct InputAction.CallbackContext 这个结构体将作为动作逻辑被触发时事件的参数使用，内部含有关于本次触发情况的所有参数。 InputBindings表示动作逻辑和输入设备之间的绑定关系。每个 Binding 需要有源输入设备（Path）和绑定的动作逻辑（Input Action），可以有输入条件限制（Interactions）限制设备的触发条件和后处理器（Processors）来进行输入源数据的后处理。 一个绑定可能有以下几种合成类型（Composite Type）：1D Axis, 2D Vector, Button, Button with modifier, Custom composite，分别表示单轴输入，双轴向量输入，按钮输入，带有条件的按钮输入和自定义输入数据类型。 Asset InputActionAssets Input Action Assets 是一种存储动作绑定关系的资源文件，扩展名为.InputActions，数据格式为 JSON。可以通过 Project 页面中 Create -&gt; Input Actions 来创建一个新的 Input Action Assets。 Input Action Assets 的编辑界面如下： 每个资源文件可以存储多个映射列表，最左侧一栏黄色标签代表不同的映射列表。中间一栏表示当前映射列表中存储的 Input Action（绿色标签），每个Input Action可以有多个Input Bindings（蓝色标签），每个Input Binding 视类型可以有多个合成分量（Composite Bindings）（粉色标签）。右侧一栏表示当前对象的属性，可以进行调整。 Input Action Assets 可以生成指定格式的 C# 类，可以通过操作该类来进行相同的操作。可以根据喜好选择生成与否。 Class PlayerInput新输入系统提供的类，可以通过添加到 Game Object 上作为组件使用。本文只介绍其 Inspector 可配置内容。 Inspector 中的 Player Input 组件： 其中： Actions 表示其使用的 Input Action Assets 资源文件，Default Map 表示其使用资源文件中的哪个映射列表。 UI Input Module 项可以通过指定一个 InputSystemUIInputModule对象来与 UI 协作。 Camera 项用于分屏游戏时指定该 Player Input 对应的摄像机对象。 Behavior 项表示当有动作逻辑触发时的相应方式，有Send Messages, Broadcast Messages, Unity Events, CSharp Events四种触发模式。分别有着慢，更慢，可视化，快的特点。但是前两个实现方式比较无脑简单，在游戏对象内实现命名为对应的 On&#123;ActionName&#125;()函数即可接受对应触发效果，Unity Events 方式需要在 Inspector 中分配各种函数，虽然可视化，但是在函数和动作逻辑较多时比较麻烦。C# Events 一如既往的优雅而又有效率，但是唯一的不足是所有自定义触发都共享同一个事件event Action&lt;InputAction.CallbackContext&gt; onActionTriggerd，需要在订阅事件之后自行比较触发的动作逻辑是否是该订阅者需要的，这种方式可以说是有利有弊。 Input System 四种基本使用方式官方给出的 Sample 给出了四种使用新输入系统的基本方式： 使用输入 State直接使用当前输入设备的状态来控制对象，没什么特别的。大概相当于用旧输入系统的思想使用新输入系统，唯一的进步大概是输入设备变得标准化了。 示例（都是英文句子就不注释了）： 12345678910111213public void Update()&#123; var gp = Gamepad.current; if (gp == null) return; Vector2 leftStick = gp.leftStick.ReadValue(), rightStick = gp.rightStick.ReadValue(); if (gp.buttonSouth.wasPressedThisFrame) Debug.Log(&quot;Pressed&quot;); if (gp.buttonSouth.wasReleasedThisFrame) Debug.Log(&quot;Released&quot;); //...&#125; 使用 Player Input 控件通过添加 Player Input 控件来管理输入，这种方式绝大部分绑定操作需要在 Inspector 中完成，代码只需要写出每个事件触发时的订阅者（命名必须为On&#123;ActionName&#125;()，C# 事件方式除外）即可。 下面是两种类型的动作逻辑值的订阅者示例（只演示两种事件类型，我拒绝SendMessage()）： 使用 Unity Event 的 Player Input 在 Inspector 中的设置: 12345678910111213141516171819202122232425262728293031public class Player : MonoBehaviour&#123; // Unity Event的情况，需要在Inspector中进行本函数的订阅操作 public void OnAttack(InputAction.CallbackContext callback) &#123; switch (callback.phase) &#123; case InputActionPhase.Performed: Debug.Log(&quot;Attacking!&quot;); &#125; move = callback.ReadValue&lt;Vector2&gt;(); &#125; // C# 事件的情况，与上方情况不共存 private PlayerInput input; private Vector2 move; private void Awake() &#123; // 添加订阅者函数, 当然也可以写成独立的函数 input = GetComponent&lt;PlayerInput&gt;().onActionTriggered += callback =&gt; &#123; if (callback.action.name == &quot;Move&quot;) &#123; move = callback.ReadValue&lt;Vector2&gt;(); &#125; &#125;; // ... &#125;&#125; 使用 Action Assets 生成的 C# 类刚才说过 Action Assets 资源文件可以生成一个 C# 类，通过建立一个这个类对象来进行控制可以达到使用资源文件相同的效果。 假设我们导出了一个CustomControl 类，则有示例： 12345678910111213141516171819202122232425public class Player : MonoBehaviour&#123; private CustomControl input; private void Awake() &#123; input = new CustomControl(); // 实例化 // 通过订阅事件的方式添加控制方式 // Player是映射列表, Attack是一个InputAction名字 input.Player.Attack.performed += callback =&gt; &#123; Debug.Log(&quot;Attacking!&quot;) &#125; &#125; private void Update() &#123; // 通过主动读取InputAction状态获取输入 Vector2 move = input.Player.Move.ReadValue&lt;Vector2&gt;(); //... &#125;&#125; 使用自定义的 Input Action 列表喜闻乐见的一点，Input Action 对象是可以在 Inspector 中显示的（废话，不然 Assets 编辑列表显示什么）。所以可以通过自定义 Input Action 对象来处理输入。 以下是一种示例： 12345678910111213141516171819202122public class Player : MonoBehaviour&#123; public InputAction moveAction; public void OnEnable() &#123; moveAction.Enable(); &#125; public void OnDisable() &#123; moveAction.Disable(); &#125; // 此时我们自定义的InputAction即可正常使用 public void Update() &#123; var move = moveAction.ReadValue&lt;Vector2&gt;(); //... &#125;&#125; 自定义的 Input Action 在 Inspector 中的显示效果： 结语当前网上关于新输入系统的中文资料真的很少，希望这篇文章能够帮到你，也希望 Unity 越来越好。 参考资料 Unity新一代输入系统介绍 - Unity Connect Manual | Input System | 1.0.0-preview.4 - Unity Docs Scripting API | Input System | 1.0.0-preview.4 - Unity Docs"},{"title":"【总结】UnityEvent 和 C# event 的差异与选择","path":"2020/02/unityevent-vs-csharpevent/","text":"Event 是一种十分方便的机制。一个 Event 就好像是一个 Youtuber，而他的粉丝 Subscribers&#x2F;Listeners 会在这个 Event 发生的时候进行响应（观看）。许多现代语言都有类似的订阅机制，比如 Java 中的 EventBus 类。 ​这种结构有利于保持各对象之间的独立性和架构的可扩展性。比如当玩家类进行开枪操作时，玩家类可以不必关心他的这个操作造成了什么结果，而只是 Invoke 一个事件。此时，粒子系统等就可以根据这个事件的发生进行在自己的处理，而玩家类并不关心这个事件造成了什么后果。这样可以起到减少耦合的作用。 C# Delegate​delegate，巨硬给出的官方翻译是委托 。delegate 本质上是一个用来存放函数的容器。众所周知，在面向对象的语言中，变量可以是值类型，也可以是引用类型。而 C# 则用 delegate 的机制将函数引用存储起来，并且可以在运行时被改变。delegate 特别用于实现事件和回调方法，一种委托将提前约定好存放的函数的返回类型和参数列表。 ​delegate 可以被初始化成一个函数的引用，也可以通过 +&#x3D;，-&#x3D; 等运算符进行存放多个函数引用。存放多个函数时，调用 delegate 将会调用所有的函数引用，这种行为叫做 multicast delegate，即委托的多播。 C# 原生 eventC# 的原生 event 其实基于 C# 的语言特性“委托” delegate。从另一个角度看，C# 的 event 就是一种 multicast delegate。 ​C# 原生事件的使用其实十分易懂。每个 event 的都需要约定一种委托类型用于存储该事件的所有订阅者，如果委托不需要参数，则使用EventArgs.Empty来进行占位。event 不需要进行实例化，订阅者只需要在订阅时对 event 进行 += 操作，退订时使用 -= 操作即可。触发事件则有直接像调用函数一样使用 () 运算符触发和使用成员函数 Invoke() 触发两种方式。 ​以下是在 Unity 中使用 C# event 的一个示例（EventManager 为事件， Listener 为订阅者）。 12345678910111213141516171819202122232425262728293031// EventManager.cs //using System;using UnityEngine;public class EventManager : MonoBehaviour&#123; // 事件参数 public class MouseDownEventArgs : EventArgs &#123; public string Message &#123; get; private set; &#125; // 构造函数 public MouseDownEventArgs(string message) &#123; Message = message; &#125; &#125; // 事件的委托声明 public delegate void MouseDownEventHandler(object sender, MouseDownEventArgs e); // 事件 static public event MouseDownEventHandler OnMouseDownEvent; private void Update() &#123; if (Input.GetMouseButtonDown(0)) &#123; // 触发事件 OnMouseDownEvent.Invoke(this, new MouseDownEventArgs(&quot;Hello!&quot;)); // OnMouseDownEvent(this, new MouseDownEventArgs(&quot;Hello!&quot;)); // 另一种触发方式 &#125; &#125;&#125; 12345678910111213141516171819202122// Listener.cs //using System;using UnityEngine;public class Listener : MonoBehaviour&#123; private void OnEnable() &#123; EventManager.OnMouseDownEvent += OnMouseDownEventInvoked; // 订阅 &#125; private void OnDisable() &#123; EventManager.OnMouseDownEvent -= OnMouseDownEventInvoked; // 退订 &#125; // 订阅者函数 private void OnMouseDownEventInvoked(object sender, EventManager.MouseDownEventArgs e) &#123; Debug.Log(string.Format(&quot;Mouse click! &#123;0&#125;, &#123;1&#125;&quot;, sender, e.Message), gameObject); &#125;&#125; UnityEvent​C# event 设计之初当然不会为了 Unity 进行优化和适配，所以 Unity 对 C# event 进行了一番魔改和封装得到了 UnityAction 和 UnityEvent 类，都包含在 UnityEngine.Event命名空间下。一定程度上简化了事件的使用（我觉得本来已经够简化了），并且支持在 Unity Editor 的 Inspector 中直接进行可视化编辑。比如 Unity 的 uGUI 的 Button 等的诸如 OnClick() 事件都是通过 UnityEvent 来实现的，所以可以在 Inspector 上可视化编辑。 ​一个UnityEvent的使用示例如下。 12345678910111213141516171819202122232425262728293031323334// 无参数 来源于 Unity Docusing UnityEngine;using UnityEngine.Events;using System.Collections;public class ExampleClass : MonoBehaviour&#123; // 事件定义 UnityEvent m_MyEvent; void Start() &#123; // 实例化事件 if (m_MyEvent == null) m_MyEvent = new UnityEvent(); // 添加订阅者 m_MyEvent.AddListener(Ping); &#125; void Update() &#123; if (Input.anyKeyDown &amp;&amp; m_MyEvent != null) &#123; // 事件触发 m_MyEvent.Invoke(); &#125; &#125; // 订阅者函数 void Ping() &#123; Debug.Log(&quot;Ping&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// 单个参数 来源于 Unity Docusing UnityEngine;using UnityEngine.Events;// 添加 System.Serializable 属性的参数才可以被 UnityEvent 使用[System.Serializable]public class MyIntEvent : UnityEvent&lt;int&gt;&#123;&#125;public class ExampleClass : MonoBehaviour&#123; public MyIntEvent m_MyEvent; void Start() &#123; if (m_MyEvent == null) m_MyEvent = new MyIntEvent(); m_MyEvent.AddListener(Ping); &#125; void Update() &#123; if (Input.anyKeyDown &amp;&amp; m_MyEvent != null) &#123; m_MyEvent.Invoke(5); &#125; &#125; void Ping(int i) &#123; Debug.Log(&quot;Ping&quot; + i); &#125;&#125; UnityEvent or C# event ？​经过 Jackson Dunstan 的性能分析（链接在后方参考资料处），可以发现 UnityEvent 在内存使用、GC回收和响应速度上都不如 C# event。如果订阅者小于等于一的情况下，UnityEvent 产生的垃圾小于 C# event，反之则要多。UnityEvent在首次触发事件时会产生垃圾，而 C# event 则没有垃圾，且前者的速度比后者慢两倍之多。C# event 在所有批量测试上都优于 UnityEvent，且触发事件越多，差距越大。最好情况下 UnityEvent 花费的时间是 C# event 的2.25倍，最坏情况下达到了40倍。 ​在实际使用中，除了性能问题之外，还会发现另外的问题。UnityEvent 是一个类，需要实例化的特点让开发者需要注意在使用该事件时该事件的实例化情况。并且在进行自定义事件参数的时候会出现很麻烦的问题，比如在 Inspector 中不显示而导致可视化的优势也莫得了等等。 ​所以，对于有一定基础并且对性能有追求的开发者来说，选择 C# event 是较好的选择。如果对性能要求不大，并且喜欢可视化编程的开发者来说，可以使用 UnityEvent 来得到更好的开发体验。当然，如果是开发 Editor Plugin 的场景，则显然使用 UnityEvent 更为恰当。所以两者的选择也需要具体情况具体分析。 参考资料 event (C# reference) - Microsoft .NET Doc Unity - Scripting API - UnityEvent C# Event vs UnityEvent vs Messaging performance - Reddit Why choose UnityEvent over native C# events? - StackOverFlow Event Performance: C# vs. UnityEvent - Jackson Dunstan"},{"title":"【总结】2019南京网络赛小结","path":"2019/09/2019-icpc-online-nanjing/","text":"The Preliminary Contest for ICPC Asia Nanjing 2019 （即 ICPC2019 南京网络赛）部分总结 A - The beautiful values of the palace题目大意整块 n * n 的地区，每个坐标都有自己的权值。权数值由中间到外围螺旋状减小（如下例），权值等于权数值的数位总和。在这片地区有 m 座城堡，对于 q 次询问，询问一个矩形范围内的城堡占点的权值和。 对于 n &#x3D; 3 和 n &#x3D; 5 的情况，点权分布情况为： 123457 8 1 13 14 15 16 016 9 2 12 23 24 17 025 4 3 11 22 25 18 03 10 21 20 19 04 09 08 07 06 05 其中，左下角为(1, 1)，右上角为(n, n)。T 组数据。 数据范围：T &lt;= 5; n &lt;= 1e6; m, p &lt;= 1e5。 题目思路将数据离散化后仍然需要 1e5 * 1e5 的大小来存储数据，不可行。 将二维问题化为一维问题，将所有数据存储到同一个结构体中，按 x 轴排序后根据 y 轴大小维护一个树状数组。 其中地图信息和询问信息全部离线到数组中统一处理，对于坐标重合的数据，将地图信息排在询问的前边。最后扫描统一处理。 参考写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e6 + 5;struct Node // 存储信息的结构体&#123; int x, y; // 坐标 int mark, id; // 标记，数值 bool operator&lt; (const Node &amp;o) const &#123; return (x != o.x)? x &lt; o.x: (y != o.y)? y &lt; o.y: mark &gt; o.mark; &#125;&#125; tile[MAXN] ;int num; // 离线的信息总大小void addtile(int X, int Y, int M, int I)&#123; num++; tile[num].x = X; tile[num].y = Y; tile[num].mark = M; tile[num].id = I;&#125;// 树状数组ll c[MAXN], top;inline int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int pos, int val)&#123; while (pos &lt;= top) &#123; c[pos] += val; pos += lowbit(pos); &#125;&#125;ll query(int pos)&#123; ll res = 0; while (pos &gt; 0) &#123; res += c[pos]; pos -= lowbit(pos); &#125; return res;&#125;// 计算 (x, y) 在一个长宽为 len 的地图中的权值int getxy(int x, int y, int len)&#123; int wid = min(min(x - 1, y - 1), min(len - x, len - y)); // 差值 ll val = 2ll * (2 * len - 2 - 2 * (wid - 1)) * wid; // 数值 len -= wid * 2; x -= wid; y -= wid; if (x == len &amp;&amp; y &gt; 1) val += (len - y + 1); else if (y == 1 &amp;&amp; x &gt; 1) val += (len - 1 + len - x + 1); else if (x == 1 &amp;&amp; y &lt; len) val += (2 * (len - 1) + y); else val += (3 * (len - 1) + x); int res = 0; // 分解数值 while (val) &#123; res += val % 10; val /= 10; &#125; return res;&#125;// 模板template &lt;class T&gt; T read()&#123; T x = 0; int w = 0, ch = getchar(); while (!isdigit(ch)) w |= ch == &#x27;-&#x27;, ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w? -x: x;&#125;int n, m, q;ll ans[MAXN];int main()&#123; int T = read&lt;int&gt;(); while (T--) &#123; n = read&lt;int&gt;(), m = read&lt;int&gt;(), q = read&lt;int&gt;(); // 初始化 for (int i = 0; i &lt;= n; i++) c[i] = 0; memset(ans, 0, sizeof(ans)); top = n; num = 0; // 读入地图数据，标记类型为 2 for (int i = 1; i &lt;= m; i++) &#123; int a = read&lt;int&gt;(), b = read&lt;int&gt;(); addtile(a, b, 2, getxy(a, b, n)); &#125; for (int i = 1; i &lt;= q; i++) &#123; int a = read&lt;int&gt;(), b = read&lt;int&gt;(), c = read&lt;int&gt;(), d = read&lt;int&gt;(); addtile(c, d, 1, i); // 进入询问区间，加上相关大小 addtile(a - 1, b - 1, 1, i); addtile(a - 1, d, -1, i); // 离开询问区间，还原 addtile(c, b - 1, -1, i); &#125; sort(tile + 1, tile + 1 + num); // 排序 // 扫描处理问题 for (int i = 1; i &lt;= num; i++) &#123; if (tile[i].mark == 2) add(tile[i].y, tile[i].id); // 城堡进入 else &#123; ans[tile[i].id] += query(tile[i].y) * tile[i].mark; // 处理 &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; printf(&quot;%I64d\\n&quot;, ans[i]); // 输出 &#125; &#125; return 0;&#125; B - super_log题目大意求 a 的 b 个 a 次幂模 m 的值，即：$$\\begin{equation}\\underbrace{a^{a^{a^{…}}}}_{b\\ times} (mod\\ m)\\end{equation}$$ 题目思路使用欧拉定理递归降幂，需要特判 a 和 m 不互质的情况。 欧拉函数会很快迭代到 1，可以提前退出，速度很快。 扩展欧拉定理：ab≡{abgcd(a,p≠1,b&lt;ϕ(p))ab%ϕ(p)+ϕ(p)&nbsp;&nbsp;(mod&nbsp;p) F - Greedy Sequence题目大意对于 n 个数字，k 的搜索半径，一个长度为 n 的字典池。要求以 1 到 n 为序列首位，构造 n 个序列。 对于每个序列，每次以当前最后一位为原点，选择字典池中半径为 k 的最大值，直到无法选择。 如对于 n = 7, k = 2, dic[] = &#123;3, 1, 4, 6, 2, 5, 7&#125;，构造的七个序列分别为： 1234567123, 14, 3, 15, 26, 5, 27, 5, 2 求构造的 n 个序列的长度，如上述样例，输出为1 1 2 3 2 3 3 。 题目思路简单的 DP，字典序最大，则每次只选择能选择的最大值，找到后 break 即可。 参考写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 5;int n, k;map&lt;int, int&gt; plc; // 每个字符的位置template &lt;class T&gt; T read()&#123; T x = 0; int w = 0, ch = getchar(); while (!isdigit(ch)) w |= ch == &#x27;-&#x27;, ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w? -x: x;&#125;int main()&#123; int T = read&lt;int&gt;(); while (T--) &#123; n = read&lt;int&gt;(), k = read&lt;int&gt;(); vector&lt;int&gt; dp(n + 1, 1); // 初始化，每个序列最小长度为 1 for (int i = 0; i &lt; n; i++) &#123; int u = read&lt;int&gt;(); plc[u] = i; &#125; dp[1] = 1; // 以 1 开头长度一定为 1 for (int i = 2; i &lt;= n; i++) &#123; for (int j = i - 1; j &gt; 0; j--) &#123; int len = abs(plc[j] - plc[i]); if (len &gt; k) continue; dp[i] = dp[j] + 1; break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d%c&quot;, dp[i], &quot; \\n&quot;[i == n]); &#125; &#125;&#125; H - Holy Grail题目大意你的英灵的宝具是一个带负权有向图（？）。你需要在指定的六个位置依次连接六条此位置允许的最小边，使不出现负权环，否则你会被圣杯吞噬（？）。数据保证答案存在。 题目思路要使不出现负权环，则需要在指定位置创建零权环。要在 x -&gt; y 连边创建零权环，则所需权值为 y -&gt; x 最短路的相反数。每次跑一下最短路并连接新边即可。 参考写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 305;const int MAXM = 505;template &lt;class T&gt; T read()&#123; T x = 0; int w = 0, ch = getchar(); while (!isdigit(ch)) w |= ch == &#x27;-&#x27;, ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w? -x: x;&#125;struct Edge // 链式前向星&#123; int to; ll cost; int next; Edge(int t = 0, ll c = 0, int ne = 0) &#123; to = t; cost = c; next = ne; &#125;&#125;;struct Spfa // SPFA&#123; vector&lt;int&gt; head; queue&lt;int&gt; q; vector&lt;Edge&gt; edges; ll dis[MAXN]; int vis[MAXN]; Spfa(int maxn) &#123; // 构造时初始化 head = vector&lt;int&gt;(maxn, 0); edges = vector&lt;Edge&gt;(1); &#125; void addedge(int u, int v, ll w) &#123; edges.emplace_back(Edge(v, w, head[u])); head[u] = edges.size() - 1; &#125; ll run(int start, int fin) // 开跑 &#123; memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[start] = 0; vis[start] = 1; q.push(start); while (q.size()) &#123; int u = q.front(); for (int i = head[u]; i; i = edges[i].next) &#123; int v = edges[i].to, w = edges[i].cost; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125; q.pop(); vis[u] = 0; &#125; return dis[fin]; &#125;&#125;;int main()&#123; int T = read&lt;int&gt;(); while (T--) &#123; int n = read&lt;int&gt;(), m = read&lt;int&gt;(); Spfa spfa(n); for (int i = 0; i &lt; m; i++) &#123; int u = read&lt;int&gt;(), v = read&lt;int&gt;(); ll w = read&lt;ll&gt;(); spfa.addedge(u, v, w); &#125; for (int i = 0; i &lt; 6; i++) &#123; int x = read&lt;int&gt;(), y = read&lt;int&gt;(); ll now = spfa.run(y, x); // 反向最短路 spfa.addedge(x, y, -now); // 连边 printf(&quot;%I64d\\n&quot;, -now); // 输出 &#125; &#125; return 0;&#125;"},{"title":"【折腾】一个小时用树莓派搭建私有Git站","path":"2019/08/gogs/","text":"将吃灰的树莓派改造成一个属于自己的 Git 站点。 前言之前一时冲动买的树莓派一直放在宿舍吃灰，在我入手 Mi Air 轻薄本之后他彻底地失去了作为 Linux 二号机的作用。今天看到 GitHub 疑似封锁伊朗用户的消息，突发灵感，将树莓派搞成了一个个人 Git 站。 前置 吃灰树莓派 一块 （本文为 Model 3B &#x2F; Raspbian 10 buster） 用来内网穿透的VPS 一台（本文为 Ubuntu 18.04 LTS ） 内网穿透工具 frp 树莓派请下载 linux_arm 版本包，VPS 则具体情况具体分析，本例中为 linux_amd64 轻量 Git 部署包 gogs 树莓派请下载 raspi2_armv6 版本包 局域网搭建 gogs 先将 gogs 的二进制安装包放到一个安全的位置，如 /var/gogs/ 解压放好。 创建 /lib/systemd/system/gogs.service 以后台运行 gogs： 12345678910111213141516[Unit] Description=Gogs After=syslog.target After=network.target [Service] Type=simple User=pi Group=pi WorkingDirectory=/var/gogs/ # 路径ExecStart=/var/gogs/gogs web # gogs路径Restart=always Environment=USER=pi HOME=/home/pi [Install] WantedBy=multi-user.target sudo systemctl enable gogs &amp;&amp; sudo systemctl start gogs来启动服务。 sudo systemctl status gogs查看运行状态，若为 active 则进行下一步。 局域网访问 树莓派局域网ip:3000来进入 gogs 的首次运行设置。 设置完成后，可以编辑 /var/gogs/custom/app.ini来调整站点设置。 至此，本地 gogs 服务已经搭设完毕。 内网穿透 - 服务器设置 将对应版本的 frp 放到安全的位置，如 /var/frp/。 修改 server 端的配置文件/var/frp/frps.ini： 12345678[common]bind_port = 7000 # 穿透用端口vhost_http_port = 80 # http 访问端口vhost_https_port = 443 # https 访问端口dashboard_port = 8888 # frps 控制面板访问端口dashboard_user = USERNAME # 控制面板用户名/密码dashboard_pwd = PASSWORDauth_token = TOKEN # 穿透用 token 创建服务 /lib/systemd/system/frps.service： 1234567891011[Unit]Description=frps serviceAfter=network.target network-online.target syslog.targetWants=network.target network-online.target[Service]Type=simpleExecStart=/var/frp/frps -c /var/frp/frps.ini[Install]WantedBy=multi-user.target sudo systemctl enable frps &amp;&amp; sudo systemctl start frps来启动服务。 sudo systemctl status frps，若服务启动完成，则可以通过 服务器ip:控制面板端口查看状态。 内网穿透 - 树莓派设置 将对应版本的 frp 放到安全的位置，如 /var/frp/。 修改 server 端的配置文件/var/frp/frpc.ini： 12345678910111213141516171819202122232425262728293031[common]server_addr = 服务器IPserver_port = 7000login_fail_exit = falseauth_token = TOKEN# 树莓派SSH[sshpi]type = tcplocal_port = 22remote_port = 2222 local_ip = 127.0.0.1 # gogs HTTP[httpgit]type = httplocal_port = 80custom_domains = YOUR.DOMAIN.COM# gogs HTTPS[httpsgit]type = httpslocal_port = 443custom_domains = YOUR.DOMAIN.COM# gogs ssh # 需打开 gogs 对应功能[sshgit]type = tcplocal_port = 对应gogs设置端口local_ip = 127.0.0.1remote_port = 50022 创建服务 /lib/systemd/system/frpc.service： 1234567891011[Unit]Description=frpc serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/var/frp/frpc -c /var/frp/frpc.ini[Install]WantedBy=multi-user.target sudo systemctl enable frpc &amp;&amp; sudo systemctl start frpc来启动服务。 若一切正常，现在已经可以通过设置的域名访问 gogs 服务了。 配置 SSL没有小绿锁的站点是没有灵魂的。 本过程需要一个对应域名的 SSL 证书（pem 和 key），树莓派需要 nginx 环境。 将 SSL 证书放到安全的位置，如/var/nginx/ssl/domain.pem和./domain.key 编辑 nginx 默认站点配置，一般在/etc/nginx/sites-enabled/default或者/var/nginx/相应位置： 添加新 server 项目： 123456789101112131415161718192021server &#123; listen 80; listen 443; server_name YOUR.DOMAIN.COM; ssl on; ssl_certificate /var/nginx/ssl/domain.pem; ssl_certificate_key /var/nginx/ssl/domain.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; if ($ssl_protocol = &quot;&quot;) &#123; return 301 https://$host$request_uri; &#125; location /&#123; proxy_pass http://127.0.0.1:3000/; proxy_set_header Host $host; &#125;&#125; 保存，通过sudo nginx -s reload刷新配置。 大功告成！Enjoy it。 示例我树莓派上部署的 gogs 站点：https://git.dctewi.com 截图"},{"title":"【杂项】竞赛向 vimrc 配置小结","path":"2019/08/vimrc/","text":"竞赛向简洁风 vim 配置。 前言俗话说，Vim 大法好。 前一段时间写题一直用的是 VS Code，VS Code 扩展丰富，功能强大，补全智能，跨平台。虽然打开的速度比较慢，但总体上来说用来写代码是真的舒服。 但可惜的是比赛中并没有 VS Code 可以拿来用。习惯了 IntelliCode 强大的基于文本和词法分析的补全功能之后，我发现自己连一行ios::sync_with_stdio(false);都不想写了。裸手代码能力在慢慢消退。 痛定思痛，我决定换回比赛中可以使用的 IDE 比如 Code::Blocks，但是在我的 Manjaro 笔记本的暗色微风主题下，CB 的界面充斥着各种暗色控件和亮色 Border ，变得特别丑，我还不如去用 Kate 或者 GEdit。这个时候，我突然回想起了在我开始用 Sublime Text 之前使用的神的编辑器 —— Vim。在花了大概一个多小时配置了一下 Vim之后，我已经完全爱上 Vim 啦！ 这套配置遵守了以下的几个原则： 不使用任何插件。因为比赛环境中是没有网络可以给 Vim 装插件的。 尽量轻量，避免任何意义不大的配置。因为比赛中给选手用来调配置的时间并不多，应该在尽量快的时间内完成平常使用的配置。 本文不再记录 vim 的基本操作，请自行网上查询或者查看我之前的文章。 逐条说明话不多说，先逐条说明一下，在文章最后有单独的代码块： 1234567if !exists(&quot;g:os&quot;) if has(&quot;win64&quot;) || has(&quot;win32&quot;) || has(&quot;win16&quot;) let g:os = &quot;win&quot; else let g:os = &quot;unix&quot; endifendif 首先判断当前环境究竟是 Windows 还是 Linux，因为我平常会在两种环境下写代码，所以根据不同的情况需要进行不同配置。 基础设置：123456789101112set nocompatible &quot; 取消 vi 兼容模式set showcmd &quot; 右下角显示当前输入的命令set mouse=a &quot; 允许鼠标选中set backspace=2 &quot; 绑定 backspace 键到模式2set encoding=utf-8 &quot; 设定默认文件编码set t_Co=256 &quot; 使用256色终端filetype indent on &quot; 根据文件类型自动判断缩进类型if g:os == &quot;win&quot; &quot; 将默认 yank 操作的寄存器设置为系统寄存器+/* set clipboard=unnamed &quot; 设置之后就可以用 y/p 操作系统剪切板了else set clipboard=unnamedplusendif 这里的 clipboard 设定需要 vim 的 X11 支持，请事先使用 vim --version | grep clipboard查看是否有 +clipboard。如果是减号，则需要安装 vim-gtk包或者 gvim包。 行为设置123set noswapfile &quot; 取消 swap 文件生成set noerrorbells &quot; 取消声音提示set autoread &quot; 若文件被外部改动则自动更新内容 缩进设置12345set cindent &quot; 使用 C 系缩进方法set tabstop=4 &quot; 设定 tab 宽度为 4set shiftwidth=4 &quot; 设定自动缩进宽度为 4set expandtab &quot; 将 tab 转换为空格set softtabstop=4 &quot; 将 tab 转换为 4 个空格 显示设置123456syntax enable &quot; 启用符号高亮syntax on &quot; 开启符号高亮set number &quot; 显示行号set cursorline &quot; 高亮当前行set showmatch &quot; 高亮匹配括号以及高亮颜色设置hi MatchParen cterm=bold ctermbg=none ctermfg=blue 搜索设置1234set hlsearch &quot; 高亮匹配结果set incsearch &quot; 逐字搜索set ignorecase &quot; 不去别大小写set smartcase &quot; 若搜索关键字有大写则区别大小写 映射设置1234567if g:os == &quot;win&quot; map &lt;F5&gt; :w &lt;CR&gt; :!g++ &quot;%&quot; -o &quot;%&lt;.exe&quot; -std=c++14 -O2 -Wall -DDEBUG ; &quot;./%&lt;.exe&quot; &lt;CR&gt;else map &lt;F5&gt; :w &lt;CR&gt; :!g++ &quot;%&quot; -o &quot;%&lt;.exe&quot; -std=c++14 -O2 -Wall -DDEBUG &amp;&amp; &quot;./%&lt;.exe&quot; &lt;CR&gt;endifmap &lt;C-F5&gt; :w &lt;CR&gt; :!python3 % &lt;CR&gt; 上边是一键编译 C++ 单文件的映射，其中%表示文件名，%&lt;表示去掉扩展名的文件名，:w保存，&lt;CR&gt;, &lt;cr&gt;代表换行，:!表示在外部 Shell 中运行指令。 最后一行是按&lt;Ctrl + F5&gt; 运行 python 脚本的映射，可以根据设置将 python3 改成 python。 补全设置12345678inoremap ( ()&lt;ESC&gt;iinoremap [ []&lt;ESC&gt;iinoremap &#x27; &#x27;&#x27;&lt;ESC&gt;iinoremap &quot; &quot;&quot;&lt;ESC&gt;iinoremap &#123; &#123;&#125;&lt;ESC&gt;iinoremap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;Oinoremap &lt;F8&gt; #include&lt;bits/stdc++.h&gt;&lt;CR&gt;using namespace std;&lt;CR&gt;typedef long long ll;&lt;CR&gt; 前几个是自动补全符号，其中如果只输入大括号则单行补全，大括号后按一下回车就会将大括号展开。最后一行是 F8 补全标准文件头，竞赛向嘛，竞赛向。 GVim 设置1234567891011121314if has(&quot;gui_running&quot;) set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 set fileencoding=utf-8 &quot; 显示编码 set guioptions-=m &quot; 隐藏菜单，工具栏和滚动条 set guioptions-=T set guioptions-=r set lines=35 columns=120 &quot; 设置大小 colorscheme torte &quot; 设置配色 if g:os == &quot;win&quot; &quot; 设置字体 set guifont=Microsoft_Yahei_Mono:h11 else set guifont=Fira\\ Mono\\ 12 endifendif 这一段是当使用 vim GUI 模式也就是 GVim 的时候进行的简单配置。比赛的时候可以无视，主要是平时在 Windows 上使用 Vim 的时候用到的。 汇总12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&quot; Vim Configuration File&quot; Author: dctewi@dctewi.com&quot; Description: For minimal icpc use&quot;&quot; System Detectif !exists(&quot;g:os&quot;) if has(&quot;win64&quot;) || has(&quot;win32&quot;) || has(&quot;win16&quot;) let g:os = &quot;win&quot; else let g:os = &quot;unix&quot; endifendif&quot; Propertiesset nocompatibleset showcmdset mouse=aset backspace=2set encoding=utf-8set t_Co=256filetype indent onif g:os == &quot;win&quot; set clipboard=unnamedelse set clipboard=unnamedplusendif&quot; Utilset noswapfileset noerrorbellsset autoread&quot; Indentset cindentset tabstop=4set shiftwidth=4set expandtabset softtabstop=4&quot; Layoutsyntax enablesyntax onset numberset cursorlineset showmatchhi MatchParen cterm=bold ctermbg=none ctermfg=blue&quot; Searchset hlsearchset incsearchset ignorecaseset smartcase&quot; Compileif g:os == &quot;win&quot; map &lt;F5&gt; :w &lt;CR&gt; :!g++ &quot;%&quot; -o &quot;%&lt;.exe&quot; -std=c++14 -O2 -Wall -DDEBUG ; &quot;./%&lt;.exe&quot; &lt;CR&gt;else map &lt;F5&gt; :w &lt;CR&gt; :!g++ &quot;%&quot; -o &quot;%&lt;.exe&quot; -std=c++14 -O2 -Wall -DDEBUG &amp;&amp; &quot;./%&lt;.exe&quot; &lt;CR&gt;endifmap &lt;C-F5&gt; :w &lt;CR&gt; :!python3 % &lt;CR&gt;&quot; Auto completeinoremap ( ()&lt;ESC&gt;iinoremap [ []&lt;ESC&gt;iinoremap &#x27; &#x27;&#x27;&lt;ESC&gt;iinoremap &quot; &quot;&quot;&lt;ESC&gt;iinoremap &#123; &#123;&#125;&lt;ESC&gt;iinoremap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O&quot; Headerinoremap &lt;F8&gt; #include&lt;bits/stdc++.h&gt;&lt;CR&gt;using namespace std;&lt;CR&gt;typedef long long ll;&lt;CR&gt;&quot; GVimif has(&quot;gui_running&quot;) set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 set fileencoding=utf-8 set guioptions-=m set guioptions-=T set guioptions-=r set lines=35 columns=120 colorscheme torte if g:os == &quot;win&quot; set guifont=Microsoft_Yahei_Mono:h11 else set guifont=Fira\\ Mono\\ 12 endifendif 文章中 vimrc 不随着我的更新而更新。我当前使用的 vimrc 可在我的Github上找到。 以上，Happy Vimming Everyday！"},{"title":"【算法】差分约束小结","path":"2019/07/difference-constraints/","text":"差分约束系统(System of Difference Constraints)的基本概念，思路和用法以及例题总结。 基本概念差分约束系统(System of Difference Constraints)，是求解关于一组变数的特殊不等式组的方法。 如果一个系统由n个变量和m个约束条件组成，其中每个约束条件形如 $x_i-x_j&lt;&#x3D;b_k (i, j\\in[1, n],\\ k\\in[1, m])$，则称其为差分约束系统。 代数解法求差分约束的最大值，可以将某几个不等式加减组合形成我们需要求解的不等式，然后得到答案。 图论解法差分约束系统都可以转化成单源最短路（或者最长路）问题。 转化： 将 $x[i]-x[j]&lt;&#x3D;b[k]$ 移项转化为 $x[i]&lt;&#x3D;x[j]+b[k]$ ，形式上与松弛操作dis[v] = dis[u] + edge[u][v]相似。 则我们将每个不等式转化成一条边，x[i] - x[j] &lt;= b[k]转化为由 j 到 i ，边权为 b[k] 的有向边。 则要求x[n - 1] - x[0]的最大值，可以转化为求 0 -&gt; n - 1的最短路； 反之，最小值将转化为两点之间的最长路问题。 一种理解方式求x[i] - x[j] &lt;= b[k]的最大值，则需要求这些b[k]中最小的，即约束最严苛的一个不等式。 反之，求x[i] - x[j] &gt;= b[k]的最小值，则需要求这些b[k]中最大的值。 解的存在性判断如同最短路问题中的负环 &#x2F; 终点不联通情况，在求解差分约束问题时同样存在对应版本的特殊情况。 1 - 最大值负环 &#x2F; 最小值正环若求解最短路负环，则最短路可以是无限小。此时我们认为最大值和最短路不存在。 对应的SPFA判断操作：若某一点的入队次数大于节点数，则认为不存在。 2 - 终点未联通表示两点之间没有约束关系，最大值和最小值为正负无穷。实现过程中由dis[n - 1] = INF来表示。 例题 题目链接：洛谷P1993 - 小K的农场 题意转化： 题目中给了三种情况，分别是： a - b &lt;= c a - b &gt;= c a == b 分别转换成 a &gt;= b + c 和 b &gt;= a - c。 要求判断是否条件不矛盾，当条件有环时则说明矛盾（如 a &gt; b, b &gt; c, c &gt; a），则题目可以转化为判断是否有环。对于以上的形式： 建立 b --&gt; a, cost = c的边 建立a --&gt; b, cost = -c的边 建立a &lt;-&gt; b, cost = 0的边 对于大于等于，求最小值，最长路，则求是否存在正环（若整理成小于等于则恰好相反）。 优化点 对于这道题，我们只需要判断是否有环，所以我们可以采用DFS形式的SPFA。深度优先使得算法在查找环时的效率倍增。但是对于求距离的题目，则传统BFS更优。 超级源点 0，通过边权为0的边连通每一个点，使图联通。 链式前向星存图。 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e4 + 5;const int INF = 1 &lt;&lt; 30;int n, m;struct Edge&#123; int to, cost, next;&#125; edge[MAXN &lt;&lt; 2];int head[MAXN &lt;&lt; 2];void add_edge(int u, int v, int w)&#123; static int cnt = 0; cnt++; edge[cnt].to = v; edge[cnt].cost = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;int vis[MAXN], dis[MAXN], flag = 0;void spfa(int u)&#123; if (flag) return; vis[u] = 1; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to, w = edge[i].cost; if (dis[v] &lt; dis[u] + w) &#123; if (vis[v] || flag) &#123; flag = 1; break; &#125; dis[v] = dis[u] + w; spfa(v); &#125; &#125; vis[u] = 0;&#125;int main()&#123; ios::sync_with_stdio(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int opt, a, b, c; cin &gt;&gt; opt &gt;&gt; a &gt;&gt; b; switch (opt) &#123; case 1: &#123; cin &gt;&gt; c; add_edge(b, a, c); break; &#125; case 2: &#123; cin &gt;&gt; c; add_edge(a, b, -c); break; &#125; case 3: &#123; add_edge(a, b, 0); add_edge(b, a, 0); break; &#125; default: break; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; add_edge(0, i, 0); dis[i] = -INF; &#125; spfa(0); cout &lt;&lt; ((flag)? &quot;No\\n&quot;: &quot;Yes\\n&quot;); return 0;&#125; 小结以上就是差分约束的基本总结以及例题。 冻葱Tewi 于 2019-07-19"},{"title":"【数学】微积分A2小结","path":"2019/06/calculus-a2/","text":"考前复习总结——微积分A2篇。 新渲染环境的Latex有一点缺陷，一些复杂Latex不能正常显示。如果想知道到底是啥样，可以自己复制走渲染一下（）。 偏导数多元复合函数偏导数对于$F &#x3D; u(x) + v(x) + w(x)$，有：$$\\frac {\\partial F} {\\partial x} &#x3D; \\frac {\\partial F} {\\partial u}·\\frac {\\partial u} {\\partial x}+\\frac {\\partial F} {\\partial v}·\\frac {\\partial v} {\\partial x}+\\frac {\\partial F} {\\partial w}·\\frac {\\partial w} {\\partial x}$$以此类推。 注意：偏导数符号$\\partial$只能对多元函数使用，若对应函数是单元函数，则应该使用微分符号$d$。 多元隐函数的偏导数若隐函数$F &#x3D; f(x, y, z)$，其中 z 是关于 x, y 的函数，则：$$\\frac {\\partial z} {\\partial x} &#x3D; -\\frac {\\frac {\\partial F} {\\partial x}} {\\frac {\\partial F} {\\partial z}}$$对于 y 的偏导数也类似，约分后其实是一样的。 方向导数若函数f(x, y)在点P(x0, y0)可微分，那么函数在该点任意方向l的方向导数存在且有：$$\\frac{\\partial f}{\\partial l}|_{(x_0,y_0)}&#x3D;f’_x(x_0,y_0)cos\\alpha+f’_y(x_0,y_0)cos\\beta$$ 梯度令grad&nbsp;f(x0,y0)&#x3D;∇f(x0,y0)&#x3D;fx′(x0,y0)i+fy′(x0,y0)j∇&#x3D;∂∂xi+∂∂yj若函数f(x,y)在点P(x0,y0)可微分，el&#x3D;(cosα,cosβ)是与l同向的单位向量则:∂f∂l|(x0,y0)&#x3D;fx′(x0,y0)cosα+fy′(x0,y0)cosβ&#x3D;grad&nbsp;f(x0,y0)⋅el&#x3D;|grad&nbsp;f(x0,y0)|cosθ其中θ&#x3D;grad&nbsp;(f(x0,y0),&nbsp;el)^ 一些性质成员相同，则结果相同，与路径无关。$$\\frac {\\partial^2 Z} {\\partial x \\partial y} &#x3D; \\frac {\\partial^2 Z} {\\partial y \\partial x}$$ 全微分多元函数的全微分$$dZ&#x3D;\\frac {\\partial Z} {\\partial x}dx + \\frac {\\partial Z} {\\partial y}dy+…$$ 由全微分求未知参数先把全微分中的$\\frac {\\partial Z} {\\partial x}$对应到具体的表达式，然后对另外一个变量求偏导。因为成员相同则结果相同，得到方程。求解即可。 多元函数求极值 求出满足$\\frac {\\partial z} {\\partial x} &#x3D; 0$和$\\frac {\\partial z} {\\partial y} &#x3D; 0$的解$(x, y)$。 令$ A &#x3D; \\frac {\\partial^2 z}{\\partial x^2},B&#x3D;\\frac {\\partial^2 z}{\\partial x\\partial y}, C&#x3D;\\frac {\\partial^2 z}{\\partial y^2} $，将第一步的解代入，求出A, B, C。 求$B^2-AC$的值，有：B2−AC{&lt;0,A&lt;0极大值&lt;0,A&gt;0极小值&#x3D;0不确定&gt;0不是极值点 极值为函数在(x, y)的值。 多元隐函数求极值与上述步骤相似，第一步中的方程组加上原方程。 多元函数求最值 求出偏导&#x3D;0的解。 找出定义域的边界。 将解和边界都带入原函数，求出结果。 (对于式子，取最大值和最小值。) 取这些函数值的最值。 一些知识点 如果一个多元函数的偏导在某一点连续，那么该函数在改点可微。 如果一个多元函数在某一点可微，则这个函数在该点连续。 如果一个多元函数在某一点可微，则这个函数在该店有偏导。 连续与偏导无关。 1234graph LR偏导连续--&gt;函数可微函数可微--&gt;函数连续函数可微--&gt;函数能偏导 空间向量向量长度$$|\\vec a|&#x3D;\\sqrt {a^2_1+a^2_2+…}$$ 向量点乘$$\\begin{equation}\\begin{aligned} \\vec a\\cdot\\vec b &amp;&#x3D;(x_1,y_1,z_1)\\cdot(x_2,y_2,z_2)\\ &amp;&#x3D;x_1x_2+y_1y_2+z_1z_2\\end{aligned}\\end{equation}$$ 向量叉乘a→×b→&#x3D;(a1,a2,a3)×(b1,b2,b3)&#x3D;|i→j→k→a1a2a3b1b2b3|&#x3D;i→|a2a3b2b3|+j→|a1a3b1b3|+k→|a1a2b1b2| 向量夹角$$\\vec a\\cdot\\vec b&#x3D;|\\vec a|\\cdot|\\vec b|\\cdot cos\\theta$$ 向量投影$$|\\vec{a_{Projection}}|&#x3D;\\frac {\\vec a\\cdot\\vec b}{|\\vec b|} \\\\vec {a_{Projection}}&#x3D;|\\vec{a_{Projection}}|\\cdot\\frac {\\vec b}{|\\vec b|}$$ 一些结论 点乘为0，则向量垂直。 叉乘为0，则向量平行。 向量各坐标成比例，则向量平行。 若 向量a × 向量b &#x3D; 向量c，则 c 垂直于 a, b 和其所在平面。 空间几何表示方法$$平面方程：Ax+By+Cz+D&#x3D;0 \\对应法向量：\\vec n&#x3D;(A, B, C) \\$$ 直线L经过点M(x0,y0,z0),且方向向量为s→&#x3D;(l,m,n)则L:x−x0l&#x3D;y−y0m&#x3D;z−z0n两个面联立表示其交线，叫做直线的一般式方程 点到面的距离$$d&#x3D;\\frac {|Ax_0+By_0+Cz_0+D|}{\\sqrt {A^2+B^2+C^2}}$$ 点到线的距离d&#x3D;(xp−x0)2+(yp−y0)2+(zp−z0)2其中，xp、yp、zp为方程组{l(x−x0)+m(y−y0)+n(z−z0)直线方程的解 曲线在某点处的切线和法平面对于曲线{x&#x3D;x(t)y&#x3D;y(t)z&#x3D;z(t)在点(x(t0),y(t0),z(t0))的切线方程为:x−x(t0)x′(t0)&#x3D;y−y(t0)y′(t0)&#x3D;z−z(t0)z′(t0)法平面方程为:x′(t0)[x−x(t0)]+y′(t0)[y−y(t0)]+z′(t0)[z−z(t0)]&#x3D;0 若不是参数方程形式的曲线，可以把$x’(t)$看作1，把整体对$x$求导得到$y’_x$和$z’_x$,代入上式 曲面在某点处得切平面与法线在点(x0,y0,z0)处的切平面方程为:Fx′(x0,y0,z0)(x−x0)+Fy′(x0,y0,z0)(y−y0)+Fz′(x0,y0,z0)(z−z0)&#x3D;0法线方程为:x−x0Fx′(x0,y0,z0)&#x3D;y−y0Fy′(x0,y0,z0)&#x3D;z−z0Fz′(x0,y0,z0) 二重积分$\\int dx\\int dy\\ $格式的二重积分 将未知数集中到后边； 计算后半部分积分； 计算前半部分积分； 交换积分次序 把未知数集中到后边； 画出积分区域； 将x和y的数字&#x2F;式子交换，使之表示同一片区域； 写出交换结果 $\\iint_{\\Sigma}d\\sigma\\ $格式的二重积分 画出积分区域； 分离 x 和 y； 将$d\\sigma\\ $改成$dxdy\\ $； 化为$\\int dx\\int dy\\ $格式的二重积分求解； 与圆有关的二重积分$$令\\ x&#x3D;rcos\\theta,\\ y&#x3D;rsin\\theta,\\ dxdy&#x3D;rd\\theta dr$$ 对称区域的二重积分关于x轴对称，则若f(−x,y)&#x3D;{−f(x,y),则∬Df(x,y)dσ&#x3D;0f(x,y),则∬Df(x,y)dσ&#x3D;2∬D2f(x,y)dσy轴同理，原点为f(−x,−y)与f(x,y)的关系。 特殊情况$$\\iint1d\\sigma&#x3D;区域面积$$ 三重积分计算三重积分$\\iiint_\\Omega xdV$，其中Omega常见类型为： 面Ax+By+Cz+D&#x3D;0与三个坐标面球面(x−x0)2+(y−y0)2+(z−z0)2&#x3D;R2椭球面x2a2+y2b2+z2c2&#x3D;1抛物面ax2+by2&#x3D;A−z与平面z&#x3D;0锥面z&#x3D;ax2+by2与平面z&#x3D;A 使用z&#x3D;?的形式表示上表面和下表面； 求$g(x, y)&#x3D;\\int_{下表面}^{上表面}f(x, y, z)dz$； 求$\\Omega在平面xOy的投影Dxy$； 答案$&#x3D;\\iint_{Dxy}g(x, y)d\\sigma\\ $； 曲线积分第一类曲线积分（质量）对于曲线L&#x3D;{x&#x3D;x(θ)y&#x3D;y(θ)(α≤θ≤β)∫Lf(x,y)ds&#x3D;∫αβf(x(θ),y(θ))⋅(x′(θ))2+(y′(θ))2dθ对于直线L:y&#x3D;y(x),将θ换成x,视为:{x&#x3D;xy&#x3D;y(x) 多段积分，互相加减。 第二类曲线积分（坐标轴）对于曲线L&#x3D;{x&#x3D;x(θ)y&#x3D;y(θ)(α≤θ≤β)∫LP(x,y)dx+Q(x,y)dy&#x3D;∫αβP(x(θ),y(θ))⋅x′(θ)+Q(x(θ),y(θ))⋅y′(θ)dθ对于直线L:y&#x3D;y(x),将θ换成x,视为:{x&#x3D;xy&#x3D;y(x) 多段积分，互相加减。 格林公式对于第二类曲线积分∫LP(x,y)dx+Q(x,y)dy,若L为正向(逆时针)无交叉闭曲线,且P,Q在L的区域内有连续的一阶偏导,则∮LPdx+Qdy&#x3D;∬D(∂Q∂x−∂P∂y)dxdy逆时针则取负号。 重要结论$$对于第二类曲线积分\\int_LP(x, y)dx+Q(x,y)dy, \\若\\frac{\\partial Q}{\\partial x}&#x3D;\\frac{\\partial P}{\\partial y},则积分与路径无瓜。$$ 特殊情况$$\\int_L1ds&#x3D;L长度$$ 曲面积分第一类曲面积分（质量）当Σ:z&#x3D;z(x, y)时 公式：$$\\iint_\\Sigma f(x,y,z)ds&#x3D;\\iint_{Dxy}f(x,y,z(x,y))\\cdot\\sqrt{1+(\\frac{\\partial z}{\\partial x})^2+(\\frac{\\partial z}{\\partial y})^2}dxdy$$ 画出Σ，表示出投影Dxy； 将Σ表示成z&#x3D;?的形式，求出f(x, y, z(x, y))； 求出z对x, y的偏导数； 代入公式； Σ的其他形式以此类推。 第二类曲面积分（流量）对于$\\iint_\\Sigma P(x, y, z)dydz$从x正向向负向看:{能看到曲面Σ∬ΣP(x,y,z)dydz&#x3D;∬DyzP(x(y,z),y,z)dydz看不到曲面Σ∬ΣP(x,y,z)dydz&#x3D;−∬DyzP(x(y,z),y,z)dydz曲面Σ缩成线∬ΣP(x,y,z)dydz&#x3D;0答案$ans&#x3D;\\sum{ 所有部分 }$ 对于其他情况($dxdz, dxdy$)，以此类推。 Gauss公式$$\\iint_{\\partial\\Omega}Pdydz+Qdzdx+Rdxdy&#x3D;\\iiint_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})dxdydz$$ 微分方程可分离变量的微分方程 分离变量 两边积分 复合的微分方程 换元代入 分离积分 换回x, y 一阶线性系数非齐次微分方程形如$y’&#x3D;P(x)y&#x3D;Q(x)\\ $的微分方程叫做一阶线性系数非齐次微分方程， 通解为：$$y&#x3D;e^{-\\int P(x)dx}\\cdot[\\int Q(x)e^{\\int P(x)dx}dx + C]$$ 二阶线性系数非齐次微分方程首先有表： 特征方程的根 通解形式 $单实根a$ $C\\cdot e^{ax}$ $k重实根a$ $e^{ax}(C_1+C_2x+…+C_kx^{k-1})$ $一对单复根a+bi$ $e^{ax}(C_1cosbx+C_2sinbx)$ $一对k重复根a+bi$ $e^{ax}[(C_1+C_2x+…+C_kx^{k-1})\\cdot cosbx \\+(D_1+D_2x+…+D_kx^{k-1})\\cdot sinbx]$ 求通解$\\overline y\\ $: 将x项暂时改为零； 将$y^{(n)}\\ $改写成$r^n \\ $，得到特征方程； 分解因式，求方程解，得到特征根； 根据特征根情况，对每个特征根划分类型； 各个特征根的结果相加即为通解； 求特解$y^*\\ $: 将 x 项都化成$x^me^{\\lambda x}\\ $的形式，得出 m 和 λ ； 根据 λ 的值确定k的值：$$\\begin{cases}\\lambda 不是特征方程的根 &amp;\\Rightarrow k&#x3D;0 \\\\lambda 是特征方程的单根 &amp;\\Rightarrow k&#x3D;1 \\\\lambda 不是特征方程多重根 &amp;\\Rightarrow k&#x3D;2 \\\\end{cases}$$ 该特解为：$$y^*&#x3D;x^k(b_0x^m+b_1x^{m-1}+…+b_mx^0)e^{\\lambda x}$$ 将得出的特解代入题干式子，求出b，消参； 求出特解； 微分方程的解为$$y&#x3D;\\overline y+\\sum y^*_i$$ 后记本小结到此结束，课标为郑州大学出版社的《微积分A2》。 本小结由冻葱Tewi撰写于20190622。"},{"title":"【捣鼓】WSL部署总结","path":"2019/04/wsl-setup/","text":"Windows Subsystem for Linux 是微软在Windows 10和 Windows Server 2019上添加的能够原生运行Linux二进制可执行文件的兼容层。 简单的记录了一下部署的过程。 Windows Subsystem for Linux 简介 Windows Subsystem for Linux 是微软在Windows 10和 Windows Server 2019上添加的能够原生运行Linux二进制可执行文件的兼容层。 由于没有硬件仿真&#x2F;虚拟化（与coLinux等其他项目不同），WSL直接使用主机文件系统（通过VolFS和DrvFS）和硬件的某些部分，例如网络（Web服务器，用于例如，可以通过主机上配置的相同接口和IP地址进行访问，并且对使用需要管理权限的端口或已经被其他应用程序占用的端口共享相同的限制），这保证了互操作性。 此子系统无法运行所有Linux软件（如32位二进制文件）或需要在WSL中未实现的特定Linux内核服务的软件。由于WSL中没有“真正的”Linux内核，因此无法运行内核模块（如设备驱动程序）。 可以通过在Windows（主机）环境（例如VcXsrv或Xming）中安装X窗口系统来运行一些图形（GUI）应用程序（例如Mozilla Firefox），尽管并非没有警告，例如缺乏音频支持或硬件加速（导致图形性能不佳）。当前还没有实施对OpenCL和CUDA的支持，尽管计划在将来的版本中使用。 ——以上说明复制自Wikipedia。 总之，这是除了双系统之外，同时使用Windows和Linux的另一种轻量级的方法。虽然有局限性，但是一般的Linux使用还是没有什么问题的。对于日常学习，使用Linux而不想&#x2F;不能离开Windows的同学来说有着很大的帮助。 WSL的启用与安装首先用管理员权限打开Windows Powershell。一种可能的打开方式是：Windows徽标键 + X -&gt; Windows Powershell(管理员)(A)。 然后键入： 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 稍等片刻，会弹出按Y重启的通知。按Y之后会自动重启两到三次，再次进入桌面的时候，WSL就已经启用完毕了。 接着，需要选择一款你想要的Linux发行版。进入Microsoft Store，搜索Linux，进入Linux发行版专题。早些时候只有Ubuntu可以选择，但是现在除了Ubuntu之外还有Debian，Kali等多个发行版可以选择。当然作为只用的来Ubuntu的菜鸡，我选择了Ubuntu并下载。 安装完成之后，你的WSL就已经初步部署完毕了！ 有两种方法可以进入WSL： 通过Powershell指令bash进入WSL。 直接点击Ubuntu图标进入WSL。 打开之后，键入lsb_release -c，显示Codename: bionic。说明我们安装了Ubuntu18.04 LTS。 WSL的初步配置下载完成之后官方的数据源仓库是ubuntu仓库，由于是境外网站，而且WSL不能走SOCKS的原因，所以最好把数据源更换成国内镜像站。这里推荐清华的镜像。 首先备份原来的数据源配置文件: 1cp /etc/apt/sources.list /etc/apt/sources.list.bak 然后修改数据源配置文件，可以通过自带的vim。如果不会用的话，可以手动用Windows上的notepad++之类打开%UbuntuPath%\\LocalState\\rootfs\\etc\\apt\\sources.list修改。 全选，删除，修改成以下内容： 1234567891011deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main multiverse restricted universe 注意：这仅限于Ubuntu 18.04，即bionic版本。如果你lsb_release -c后显示的结果不是bionic，那么请将以上数据源地址中所有的bionic替换成你的版本代号。 修改保存之后，更新配置并且升级（可能会占用较长的时间，可以起身转一转）： 12sudo apt updatesudo apt upgrade 到此，WSL已经初步配置完成啦。 WSL的本地化虽说日常使用用英文也没什么大碍，但是既然有中文本地化，就没理由补折腾一番啦。 首先安装中文本地化包： 1sudo apt install language-pack-zh-hans 然后更新本地化设置： 1sudo update-locale LANG=zh_CN.UTF-8 接着安装Noto CJK包来防止中文被显示为日文字形，导致的全员小方框乱码故障： 1sudo apt install fonts-noto-cjk 重启WSL，现在已经是中文本地化模式了。 WSL配合Xming显示GUIWSL默认是没有安装图形窗口系统的（毕竟只有300MiB大），所以要想显示GUI，必须要再自己安装。 X窗口系统，是一种以位图方式显示的软件窗口系统。好像Windows自带的X.Org就是一种X窗口系统，Xming这个工具是通过给WSL提供端口来实现图形化界面的显示的。 官方的Xming已经年经失修，推荐一个魔改版本VcXsrv。下载地址：SourceForge，百度云(提取码hm4o)。 安装VcXsrv之后，启动XLaunch，开放0端口。然后打开WSL，输入： 1echo &quot;export DISPLAY=127.0.0.1:0&quot;&gt;&gt;~/.bashrc 这样就把默认的显示配置完成了。 安装Ubuntu Desktop (可选)Ubuntu-Desktop不是Ubuntu桌面，只是安装了Ubuntu GUI默认安装的图形工具，比如gedit之类。比较大，有2G那么大，而且我的Windows上也不怎么需要Ubuntu Desktop，所以我就没安装。 直接键入： 1sudo apt install ubuntu-desktop 就完事了。有2G大，估计会持续很长时间。 安装Gnome-terminal如果你安装了ubunutu-desktop可能可以跳过这一步，因为ubuntu-desktop包中应该已经安装好了Gnome-ternimal的依赖项。当然打一行指令也没啥。 1sudo apt install dbus-x11 然后就是安装了，没啥好说的。 1sudo apt install gnome-terminal 好了，安装完成。保持后台Xming服务开启，终端输入: 1gnome-terminal 然后应该就弹出终端了。 安装GeanyGeany是ICPC World Final 2019上，华沙大学队伍使用的编辑器。轻量，五脏俱全，支持C, C++, Java, Python以及各种前端语言的语法高亮和自动补全。我寻思这个支持的语言列表，难道是面向ACM开发的嘛……众所周知，Code::Blocks在Ubuntu上经常闪退，而赛场上的vim肯定没什么时间深度配置所以也不太好用，CLion要收费，所以这个Geany安装之后玩了一会儿就爱上了。 添加ppa，更新包列表，安装一气呵成： 123sudo add-apt-repository ppa:geany-dev/ppasudo apt-get updatesudo apt-get install geany 然后在终端键入geany，不出意外的话就会弹出来啦！ 在首选项里配置一番就开始玩吧！当然，别忘了安装相关语言的环境： 12345678910# C/C++sudo apt install build-essential# JDK (Unconfirmed)sudo apt install default-jresudo apt install default-jdkexport JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/bin/export JRE_HOME=$JAVA_HOME/jresource /etc/environment# Pythonsudo apt install python3 注意：Java的环境变量地址请根据自己的安装路径调整，查看安装地址可以使用： 1sudo update-alternatives --config java WSL要知道的 Windows和WSL中的路径对应关系： 磁盘根目录对应： 1234# WindowsC:\\# WSL/mnt/c/ WSL根目录对应： 1234# WindowsC:\\Users\\%USER_NAME%\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_%VERSION_HASH%\\LocalState\\rootfs\\# WSL/ 注意！请不要直接从C盘访问该地址修改内容，会导致权限混乱。Windows10-1903以上版本请在WSL运行时访问\\\\$wsl\\ 卸载WSL Powershell：lxrun /uninstall /full 一个更好的wsl终端，可以用来显示32位色： WSL-terminal on github 参考资料Windows Subsystem for Linux Installation Guide for Windows 10 适用于 Linux 的 Windows 子系统 ——维基百科，自由的百科全书 Issues with dbus-launch and x11 forwarding and &#x2F;etc&#x2F;machine-id? ——Github [Asking] WSL, Ubuntu 18.04, DBUS fix updated instruction? ——Reddit How to Install Geany IDE on Ubuntu 18.04 &amp; 16.04 LTS ——TecAdmin How To Install Java with apt on Ubuntu 18.04 ——DigitalOcean 如何正确为 Noto Sans CJK 配置 fontconfig 使中文不会被显示为日文字型？——知乎 总结以上就是本次总结的全部内容了。 人人都应该试一试Linux！玩得愉快！ 冻葱Tewi 于 2019-04-07"},{"title":"【开发】Unity的类MVC架构总结","path":"2019/03/unity-mvc/","text":"画UI画的头疼，想水一篇文章。本来想总结一下DP，但是发现东西实在是太多了，准备多写一些东西再放上来。所以先总结一下最近学到的Unity架构知识。 作为一个常年写竞赛型代码的菜鸡选手，往往不太会用这种写工程用的高级架构。但是写游戏又是一个不小的工程，所以一个清晰的架构就显得特别重要了。Unity编程中，这种类MVC架构我之前就在Unity官方案例中见到过，但是在图书馆借了相关材料之后才进行了系统的学习。 MVC架构 MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 而这种由Manager管理的结构和MVC的分工稍有出入，被书中称为类MVC架构。 类MVC架构由一个IGameManager接口封装所有Manager类的基本结构，由一个Managers总类来管理和实例化所有的Manager类，每个Manager类负责不同的模块。 这样做的优点是代码结构清晰，管理、添加和删除功能模块的时候可以把互相之间的影响降低到最小。 具体实现接口 IGameManager首先是IGameManager接口类： 1234567891011121314public enum ManagerStatus&#123; Shutdown, Initializing, Started&#125;public interface IGameManager&#123; ManagerStatus status &#123; get; &#125; void Startup();&#125; ManagerStatus枚举用来表示Manager类的实例化情况，Startup()负责分配Manager类在启动时所需要经历的行为，每个Manager内不需要单独实现private void Start()，而是在总的Managers类中统一执行Startup()。这么做可以手动控制Manager类之间的先后加载顺序来避免相互之间的依赖关系而导致的引用错误。 管理类 Managers我们拟添加存档管理器DataManager、背包管理器InventoryManager和玩家管理器PlayerManager。 总管理类不需要继承自接口，代码大概如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192using System.Collections;using System.Collections.Generic;using UnityEngine;[RequireComponent(typeof(DataManager))] // 注1[RequireComponent(typeof(InventoryManager))][RequireComponent(typeof(PlayerManager))]public class Managers : MonoBehaviour&#123; // Managers Instance public static Managers instance &#123; get; private set; &#125; // 注2 // Manager List public static DataManager Data; public static InventoryManager Inventory; public static PlayerManager Player; // Manager Load Sequeue private List&lt;IGameManager&gt; _startSequeue; // 注3 private void Awake() &#123; // Check if there isn&#x27;t an instance if (instance == null) &#123; instance = this; &#125; // Check if there is an instance else if (instance != this) &#123; Destroy(gameObject); return; &#125; // Set this Managers instance Don&#x27;t Destroy on Load DontDestroyOnLoad(gameObject); // Get Managers Instances Data = GetComponent&lt;DataManager&gt;(); Inventory = GetComponent&lt;InventoryManager&gt;(); Player = GetComponent&lt;PlayerManager&gt;(); // Add Managers to Load Sequeue _startSequeue = new List&lt;IGameManager&gt; &#123; Player, Inventory, Data &#125;; // Start Load Managers StartCoroutine(StartupManagers()); &#125; private IEnumerator StartupManagers() &#123; // Call Startup() of Every Manager foreach (var manager in _startSequeue) &#123; manager.Startup(); &#125; // Wait for Next Frame yield return null; // Check the number of Managers int numModules = _startSequeue.Count, numReady = 0; // While not Loaded while (numReady &lt; numModules) &#123; int lastReady = numReady; numReady = 0; // Get the Status of Managers foreach (var manager in _startSequeue) &#123; if (manager.status == ManagerStatus.Started) &#123; numReady++; &#125; &#125; // If undone if (numReady &gt; lastReady) &#123; Debug.Log(&quot;Progress: &quot; + numReady + &quot;/&quot; + numModules); // Wait for Next Frame yield return null; &#125; &#125; // Complete Debug.Log(&quot;All managers started up&quot;); &#125;&#125; 注1： 这里的三个属性主要有两个作用。一是表明依赖关系，二是在绑定Game Object的时候可以只拖动Managers脚本，Unity会自动添加他需要的剩下的脚本文件。 注2： 获取当前的实例，用来直接调用当前示例以及防止多次实例化。 注3： 需要被初始化的Manager列表。众所周知，出列顺序是固定的，所以解决了Start()函数先后顺序无法确定的问题。 其他的都是一些朴实的模拟过程，配合注释即可食用。 玩家管理器 PlayerManager只管理血量和血量上限，顺便带了一个更改血量的函数的简略代码： 1234567891011121314151617181920212223242526272829303132333435using UnityEngine;public class PlayerManager : MonoBehaviour, IGameManager&#123; public ManagerStatus status &#123; get; private set; &#125; public float health; public float maxHealth; public void Startup() &#123; Debug.Log(&quot;Player manager starting...&quot;); health = 50f; maxHealth = 100f; status = ManagerStatus.Started; &#125; public void ChangeHealth(float delta) &#123; health += delta; if (health &gt; maxHealth) &#123; health = maxHealth; &#125; else if (health &lt; 0) &#123; health = 0f; &#125; Debug.Log(&quot;Player HP: &quot; + health + &quot;/&quot; + maxHealth); &#125;&#125; 很朴实的代码……继承自MonoBehaviour和IGameManager，实现一下接口的要求就没什么了。 背包管理器 InventoryManager简略功能后的代码： 1234567891011121314151617181920212223242526272829using System.Collections.Generic;using UnityEngine;public class InventoryManager : MonoBehaviour, IGameManager&#123; public ManagerStatus status &#123; get; private set; &#125; private Dictionary&lt;string, int&gt; _items; public void Startup() &#123; Debug.Log(&quot;Inventory manager starting...&quot;); _items = new Dictionary&lt;string, int&gt;(); status = ManagerStatus.Started; &#125; public void UpdateData(Dictionary&lt;string, int&gt; newItems) &#123; _items = newItems; &#125; public Dictionary&lt;string, int&gt; GetData() &#123; return _items; &#125;&#125; 使用了Dictonary&lt;string, int&gt;来储存背包信息，但是这么做没有办法记录物品的摆放位置。可以再写一个位置类和物品类，然后用Dictionary&lt;Place, Item&gt;来储存，这里不再展开。 存档管理器 DataManager保留这个主要是顺带记录一下序列化&#x2F;反序列化来储存游戏存档的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System.IO;using System.Collections.Generic;using System.Runtime.Serialization.Formatters.Binary;using UnityEngine;public class DataManager : MonoBehaviour, IGameManager&#123; public static string SaveName = &quot;save.dat&quot;; public ManagerStatus status &#123; get; private set; &#125; private string _savepath; public void Startup() &#123; Debug.Log(&quot;Data manager starting...&quot;); _savepath = Path.Combine(Application.persistentDataPath, SaveName); Debug.Log(&quot;Set the &quot; + SaveName + &quot; in &quot; + _savepath); status = ManagerStatus.Started; &#125; [ContextMenu(&quot;Save&quot;)] public void Save() &#123; // Dic of objects which should be saved Dictionary&lt;string, object&gt; gamestate = new Dictionary&lt;string, object&gt; &#123; &#123; &quot;inventory&quot;, Managers.Inventory.GetData() &#125;, &#123; &quot;health&quot;, Managers.Player.health &#125;, &#123; &quot;maxHealth&quot;, Managers.Player.maxHealth &#125; &#125;; // Format the serializable object to stream FileStream stream = File.Create(_savepath); BinaryFormatter formatter = new BinaryFormatter(); formatter.Serialize(stream, gamestate); stream.Close(); &#125; [ContextMenu(&quot;Load&quot;)] public void Load() &#123; try &#123; if (!File.Exists(_savepath)) &#123; Debug.Log(&quot;No save file&quot;); throw new FileNotFoundException(); &#125; &#125; catch (FileNotFoundException) &#123; EventManager.SaveNotFoundEvent.Invoke(); return; &#125; Dictionary&lt;string, object&gt; gamestate; BinaryFormatter formatter = new BinaryFormatter(); FileStream stream = File.Open(_savepath, FileMode.Open); // Deserialize the stream to object gamestate = formatter.Deserialize(stream) as Dictionary&lt;string, object&gt;; stream.Close(); Managers.Inventory.UpdateData(gamestate[&quot;inventory&quot;] as Dictionary&lt;string, int&gt;); //... &#125;&#125; 这个保存和加载的过程涉及到了序列化&#x2F;反序列化以及C#的装箱&#x2F;拆箱操作。 保存 Dictionary&lt;string, object&gt; gamestate = new Dictionary&lt;string, object&gt;&#123;...&#125; 把所有想要保存的数据装箱。 实例化一个FileStream类对象用来输出文件，配合BinaryFormatter来把装箱后的数据保存到想要保存的位置。 关闭文件流。 加载 检查存档是否存在，若不存在则抛出异常、触发事件并返回（在这里不展开）。 创建一个接受数据的Dictionary&lt;string, object&gt; BinaryFormatter配合 FileStream从存档位置读入存档内容，关闭文件流 转换，拆箱，赋值。 小结以上就是Unity工程中类MVC架构的大致结构。 Unity天下第一！！！（被拖走暴打）"},{"title":"【算法】数论基础小结","path":"2019/02/number-theory-base/","text":"数论是纯粹数学的分支之一，主要研究整数的性质。被誉为“最纯”的数学领域。 总结了一些在寒假集训的时候学到的数论知识，不按难度排序。 关于素数素数，指除了1和它本身没有其他因数的正整数。 朴素素数判定即从定义出发，遍历从2到根号n所有数。如果存在一个数字是他的因数，则这个数不是素数。 实现代码如下： 123456789bool checkPrime(int n)&#123; for (int i = 2; i &lt; sqrt(n); i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 这种方法太过朴实，一般情况下不会用到。时间复杂度O(√n)。 埃氏素数筛法一种较为高效的判断素数的方法。能够一次性地筛选出某个区间的素数。 其中心思想是：如果某个数x是a的倍数，那么x一定不是素数。每次得到一个素数，则把他在这个区间内的所有素数都标记为合数。 实现代码如下： 1234567891011121314151617const int MAXN = 1e4 + 5;bool notPrime[MAXN];void checkPrimeTo(int uplimit)&#123; notPrime[0] = notPrime[1] = 1; for (int i = 2; i &lt;= uplimit; i++) &#123; if (!notPrime[i]) &#123; for (int j = 2 * i; j &lt;= uplimit; j += i) &#123; notPrime[j] = 1; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425### 线性欧拉筛法在埃氏筛法的基础上，通过巧妙地限制每次筛去的数字数量，保证了**每个合数只会被它的最小质因数筛去**，因此每个数只会被标记一次。实现代码如下：```cppconst int MAXN = 1e7 + 5;int notPrime[MAXN], primes[MAXN], top = 0;void checkPrimeTo(int uplimit)&#123; notPrime[0] = notPrime[1] = 1; for (int i = 2; i &lt;= uplimit; i++) &#123; if (!notPrime[i]) primes[top++] = i; for (int j = 0; j &lt; top; j++) &#123; if (i * primes[j] &gt; uplimit) break; check[i * primes[j]] = 1; if (i % primes[j] == 0) break; &#125; &#125;&#125; 123456789### Miller-Rabin素性测试首先需要了解**费马小定理**：```yaml对于素数 p 和任意整数 a ，若gcd(a, p) == 1，则有 a ^ p ≡ a (mod p)，即 a ^ (p - 1) ≡ 1 (mod p)。 那么，是否可以反过来利用这个定理来判断素数呢？基本可以。 但是有一类合数，用任何小于他们的质数为底进行判定，都满足这个定理。这种合数叫做伪素数，最小的伪素数是341。为了排除伪素数，我们引入了二次探测定理： 1对于素数 p ，则 x ^ 2 ≡ 1 (mod p) =&gt; ( x == 1 || x == p - 1 ) 则对于a ^ (x - 1) = 1 (mod p)成立，若x - 1是奇数，则不再继续判断。否则继续判断是否a ^ ((x - 1) / 2) = 1 或 -1 (mod p)成立。如果不等于1或者-1则返回false，如果等于-1则返回true，如果等于1则继续向下判断。 选择前7个素数作为a，在[2, 1e18]内也就只有两三个可以通过Miller-Rabin测试的强伪素数了。 实现代码：（q_exp()为快速幂，q_mul()为快速乘） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374typedef unsigned long long ll;const int TIMES = 20; // 测试轮数ll q_exp(ll a, ll k, ll mod)&#123; if (!k) return 1; ll ans = 1; while (k) &#123; if (k &amp; 1) ans = ans * a % mod; a = a * a % mod; k &gt;&gt;= 1; &#125; return ans;&#125;ll q_mul(ll a, ll b, ll mod)&#123; if (!b) return 0; ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return ans;&#125;inline ll random(ll n)&#123; return ((double)rand() / RAND_MAX * n + 0.5); // RAND_MAX 定义于头文件&#125;bool witness(ll a, ll n) // 二次探测&#123; ll tem = n - 1; int j = 0; while (!(tem &amp; 1)) &#123; tem /= 2; j++; &#125; ll x = q_exp(a, tem, n); if (x == 1 || x == n - 1) return true; while (j--) &#123; x = q_mul(x, x, n); if (x == n - 1) return true; &#125; return false;&#125;bool miller_rabin(ll p) // 随机生成a来二次探测&#123; if (p == 2) return true; if (p &lt; 2 || !(p &amp; 1)) return true; // 剪枝 for (int i = 1; i &lt; TIMES; i++) &#123; ll a = random(p - 1) + 1; if (!witness(a, p)) &#123; return false; &#125; &#125; return true;&#125;int main()&#123; ll n; cin&gt;&gt;n; miller_rabin(n)? puts(&quot;It&#x27;s a prime.&quot;): puts(&quot;It&#x27;s not a prime&quot;);&#125; Miller-Rabin的时间主要花在了计算a ^ (p - 1) mod p上，总体时间复杂度是O(logn)。 关于最大公因数对于最大的整数n，使得n同时是a和b的因子，则称n是a和b的最大公因数(Greatest common divisor)。 性质：gcd(a, b) * lcm(a, b) = a * b。 递归求gcd辗转相除法，直接上代码： 123456typedef long long ll;inline ll gcd(int a, int b)&#123; return b? gcd(b, a % b): a;&#125; 扩展欧几里德算法(exgcd)扩展欧几里德算法是用来解决已知a, b求解一组x, y,使它们满足: ax + by = gcd(a, b) = d的算法。 代码（接上部分代码）： 123456789101112ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if (!b) &#123; x = 1; y = 0; return a; &#125; ll r = exgcd(b, a % b, x, y); ll tem = y; y = x - a / b * y; x = tem; return r;&#125; 关于组合数组合数的定义 杨辉三角求组合数根据推论： 1C(m, n) = C(m, n - 1) + C(m - 1, n - 1) 可以预处理打表一个杨辉三角来求组合数。 代码大致为： 12345678910111213141516typedef long long ll;const int MAXN = 1e4 + 5;ll c[MAXN][MAXN];void getC(int uplimit)&#123; c[0][0] = c[1][0] = c[1][1] = 1; for (int i = 2; i &lt;= uplimit; i++) &#123; c[i][0] = 1; for (int j = 1; j &lt;= i; i++) &#123; c[i][j] = c[i][j - 1] + c[i - 1][j - 1]; &#125; &#125;&#125; 没啥注意的要点，时间复杂度O(n ^ 2)。 逆元打表求组合数步骤大概如下： 打表出1! ~ n! - O(n)。 求每个阶乘的逆元 - O(nlogn)。 直接得：C(m, n) = n! / (m! * (n - m)!) - O(1)。 总体复杂度是O(nlogn)。 Lucas定理 在数论中，Lucas定理用于计算二项式系数(m, n)被质数 p 除的所得的余数。 定理内容：对于非负整数 m 和 n 以及素数 p ，同余式： 1(m, n) ≡ Π(i = 0 -&gt; k) (m[i], n[i]) (mod p) 其中，m[i]，n[i]是 m 和 n 的 p 进制展开，当m &lt; n 时，二项式系数(m, n) = 0。 以后我学会Latex之后可能会重新写一下这里……这样平摊有点抽象_(:3。 这个方法使用递归，用于n和m巨大，但是p不太大且p为质数的时候。可直接求得： 1C(m, n) ≡ C(m % p, n % p) * C(m / p, n / p) 代码就不写了。 分块打表求组合数玄学操作，大概知道有这么一种方法就可以了。时间复杂度O(玄学)。 零散的知识点唯一分解定理任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积N = P1 ^ a1 * P2 ^ a2 * P3 ^ a3 ... Pn ^ an，这里P1 &lt; P2 &lt; P3 &lt;...&lt; Pn且均为质数，其中指数ai是正整数。这样的分解称为 N 的标准分解式。 同余定理加减乘同余模意义下，加减乘都不变，即： 1(a % c + b % c) % c == (a + b) % c 减法、乘法同理。 逆元同余逆元： 1任意 x ∈ (1, p - 1)，存在 y 使 x * y % p == 1，称 y 是 x 在 mod p 意义下的逆元 则： 1(a % c) / (x % c) != (a / x) % c 但是 1(a % c) * (y % c) % c == (a / x) % c 欧拉函数&#x2F;欧拉降幂略（逃） 以上就是寒假集训中学到的一些数论知识点。"},{"title":"【算法】KMP学习小结","path":"2019/02/kmp/","text":"学习kmp算法后的一些总结。本来没打算熬夜的结果搞到零点多。 在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可以在一个主文本字符串S内查找一个词w的出现位置。此算法通过运用对这个词在不匹配时本身旧包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。 ——Wikipedia。 算法概述简单来说，KMP算法就是用来解决字符串匹配问题的算法，即在一个主要字符串（称为主串）中寻找另一个字符串（称为模式串）是否存在的问题。 主要概念学习KMP算法之前，首先要了解这个算法的一些重要概念。 失配即“失去匹配”。指对于从l开始匹配模式串时，模式串第i位和主串第l + i位不相同，则称第i位失配。 next数组在kmp算法中，预处理出的一个数组。next[i]表示第0位~第i - 1位中，前缀与后缀相同的部分最长长度(而不是回文)。同时，next[i]也表示着当模式串在第i位失配时，当前位置要跳转到哪一位才有可能重新匹配成功。 出于我的习惯，把数据从下标0开始放：则，next[i] = -1指从第0位第i - 1位的子字符串的相同前后缀不存在（即前后缀长度是0）。next[i]代表从第0位第i - 1位最大相同前后缀的长度 - 1，同样表示失配指针下标。 推导思路在思考kmp算法之前，先来模拟一下朴素的扫描式字符串匹配算法： 朴素扫描即模式串从前向后每次移动一个单位，每次移动后从前往后检查模式串和主串相应位置的字符是否相同，如果完全相同则匹配完成，失配则继续移动。 这种匹配方法的复杂度为O(nm)，显然，这种朴素算法有丶过于暴力了。我们需要优化它。 下面举出一个扫描过程的例子： 12345678910111213141516171801234567890ABCABABCABD &lt;-主串ABCABD &lt;-模式串------ 1ABCABABCABD ABCABD------ 2ABCABABCABD ABCABD------ 3ABCABABCABD ABCABD------ 4ABCABABCABD ABCABD------ 5ABCABABCABD ABCABD 这五次移动中，中间的许多步骤是多余的。 再观察属于ABCABD的next[]: 1int nxt[] = &#123;-1, -1, -1, 0, 1, -1&#125;; 因为既然在第一步当中，D和A失配。那么他前方（不包括它本身）的子字符串与主串匹配。可以直接将当前位置跳转到next[5]，即0（-1表示触顶）的位置。则直接跳转到了最后一步，接着就可以匹配成功了。 虽然kmp算法不可能每次都准确地跳过所有地无用步骤，但是它的复杂度O(n + m)还是要比朴素算法优秀了不少。 kmp算法通过上边的推导，可以发现：kmp算法的核心就是预处理出next数组。我们通过模式串自我比对来获取next数组。 通过巧妙地设置匹配游标k，可以快速地获取指定模式串的next[]数组。而实际上，预处理过程和正式的kmp过程思路和代码几乎完全一样。 具体实现首先是预处理next数组的代码： 1234567891011121314151617typedef long long ll;const int MAXN = 1e6 + 5;ll nxt[MAXN];void getNext(string s)&#123; nxt[0] = -1; // -1 表示前后缀不存在 int k = -1; // 模式串的匹配游标 for (int i = 1; i &lt; s.size(); i++) &#123; //下一个数失配则更新本位的失配指针，k == -1则触顶 while (k != -1 &amp;&amp; s[k + 1] != s[i]) k = nxt[k]; if (s[k + 1] == s[i]) k++; // 如果游标后可以继续得到相同的前后缀 nxt[i] = k; // 更新next[]数组 &#125;&#125; 可以通过上边部分使用过的模式串ABCABD来简单模拟一下这个过程。这个过程实际上是寻找相同前后缀长度的过程，同时正得到了我们需要的next[]数组。 然后是kmp的过程： 1234567891011121314151617181920void kmp(string s, string p)&#123; int k = -1; for (int i = 0; i &lt; s.size(); i++) &#123; // 下一位失配则移动游标 &lt;=&gt; 移动模式串 while (k != -1 &amp;&amp; p[k + 1] != s[i]) k = nxt[k]; if (p[k + 1] == s[i]) k++; // 匹配成功，后移游标 if (k == p.size() - 1) &#123; // 找到某个匹配结果 k = nxt[k]; // 继续向后匹配 /// &lt;custom_code&gt; cout&lt;&lt;i - p.size() + 2&lt;&lt;endl; // 输出模式串开始位置 // +2分别是位置坐标补正和减法补正:wq /// &lt;/custom_code&gt; &#125; &#125;&#125; 其中&lt;custom_code&gt;中间是自定义的代码。一般的kmp题目输出要求可以再这里实现，这里输出的是每一个匹配成功的主串起始位置的下标。 总结简单来讲，kmp算法就是模式串先自己和自己搞一遍，在和主串搞一遍（不）。 在纸上模拟之后就可以发现这个next数组的真正用途，接着就可以豁然开朗，从而理解这个过程。 kmp算法是AC自动机的基础知识点。AC自动机本质上是kmp算法思想和tire树结构的一种结合（但是对我这种菜鸡来说还是难炸了。 以上就是冻葱Tewi的kmp算法学习小结！"},{"title":"【数据结构】线段树基础小结","path":"2019/02/segment-tree-base/","text":"学习两种线段树后的总结。 可能并不适合完全不了解线段树的人入门？但是可能会对稍微知道线段树的人有一些帮助。 线段树是一种二叉树，可以视为树状数组的变种。 该数据结构在实际应用中用途不大，但是由于其程序易于实现而呗广泛应用于程序竞赛当中。其用途是在O(logN)查询一个指定区间内的信息，并可在同样的时间复杂度内支持更新等操作。 ——Wikipedia 基本概念线段树本身是专门用来处理区间问题的数据结构，包括但不限于区间求和问题(RSQ)，区间最值问题(RMQ)等。因为本身具有树的结构特性而被称为线段“树”。 线段树是分块思想的树化，或者说是对于信息处理的二进制化。即——通过将整个序列分为有穷个小块，对于要查询的某一段区间，总是可以整合成k个子块和m个单个元素的信息的并集。 线段树只能维护满足结合律的信息，即只能维护一个幺半群序列（群论可以参见群论与快速幂）。而树状数组只能维护交换群序列。 线段树上的每一个子节点，都表示整个序列中的一段子区间。其中，每个叶子节点都表示序列中的单个元素信息。每次更新，子节点都向上传递信息，来不断更新整个线段树。 存储结构以这一棵总值线段树为例： 树上每一个节点存储的都是一个区间上的总和。 常规递归线段树建树操作一般地，我们经常采用递归的方法来创建线段树。对于节点类： 123456789101112typedef long long ll;const int MAXN = 1e5 + 5; //源数据最大长度class SegmentTreeNode&#123;public: SegmentTreeNode()&#123;&#125; //构造函数 int l, r; //该节点储存的区间左右范围 ll data, add_tag = 0, mul_tag = 1; //该节点应该储存的数据和标记*&#125;st[MAXN &lt;&lt; 2]; //线段树数组，范围×4防止越界ll raw_data[MAXN]; //原始数据 我们递归地从下向上来创建线段树： 1234567891011121314151617void build(int p, int l, int r) //p节点序号，l, r范围&#123; st[p].l = l; st[p].r = r; //处理当前区间 if (l == r) //叶节点特判 &#123; st[p].data = raw_data[l]; //赋值 return ; //触底返回 &#125; int mid = (l + r) &gt;&gt; 1; //二分递归 build(lson(p), l, mid); build(rson(p), mid + 1, r); push_up(p); //上推*&#125; push_up()操作push_up()即线段树上推操作，即把下方节点的更新情况”告知”上方节点。对于不同类型的线段树可能有所不同。在总值线段树中，上推操作为： 12345void push_up(int p)&#123; st[p].data = (st[lson(p)].data + st[rson(p)].data) % mod;&#125; 懒惰标记当我们更新时，如果每次都把整个线段树更新，那么将会耗费很多多余的时间。所以我们将每次节点的更新记录到节点内，当需要使用它下方的节点时在进行下推。标记记录的就是以这个节点为根节点的子树中经过过的更新操作。 下推懒惰标记的操作为： 1234567891011121314151617181920212223void lazy_down(int p)&#123; if (st[p].add_tag || st[p].mul_tag != 1) &#123; st[lson(p)].data = st[lson(p)].data * st[p].mul_tag % mod; st[lson(p)].mul_tag = st[lson(p)].mul_tag * st[p].mul_tag % mod; st[lson(p)].add_tag = st[lson(p)].add_tag * st[p].mul_tag % mod; st[rson(p)].data = st[rson(p)].data * st[p].mul_tag % mod; st[rson(p)].mul_tag = st[rson(p)].mul_tag * st[p].mul_tag % mod; st[rson(p)].add_tag = st[rson(p)].add_tag * st[p].mul_tag % mod; st[p].mul_tag = 1; //乘法标记下推完成，恢复初始值**1** st[lson(p)].add_tag +=st[p].add_tag; st[lson(p)].data += st[p].add_tag * (st[lson(p)].r - st[lson(p)].l + 1); st[rson(p)].add_tag +=st[p].add_tag; st[rson(p)].data += st[p].add_tag * (st[rson(p)].r - st[rson(p)].l + 1); st[p].add_tag = 0; //加法标记下推完成，恢复初始值**0** &#125;&#125; 需要注意的是，这里的线段树支持了加法和乘法操作。那么在处理加法和乘法操作时，应该注意加法和乘法的先后顺序。先处理乘法，并且用乘法标记更新加法标记（因为在做乘法操作时，加法操作也会被乘以相同的系数），然后再处理加法标记。这样才不会丢失精度以及保持数据记录的准确性。 查询操作要查询指定区间（区间长度&gt;&#x3D;1）的总和&#x2F;最大值&#x2F;最小值等时，可以想到：通过不断向下查询节点，将查询区间[l, r]的问题转化成有限个小区间以及有限个单个元素的并集，即分块思想。 具体实现代码为： 1234567891011121314151617long long query(int p, int l, int r) //p节点序号，l, r范围&#123; //若当前节点包括的数据被完全包含与所求区间，那么直接上推本节点数据 if (st[p].l &gt;= l &amp;&amp; st[p].r &lt;= r) return st[p].data % mod; //若没有完全包含，那么就需要用到下方节点，那么下推标记 lazy_down(p); //二分向下查询 ll ans = 0; int mid = (st[p].l + st[p].r) &gt;&gt; 1; if (mid &gt;= l) ans += query(lson(p), l, r); if (mid &lt; r) ans += query(rson(p), l, r); return ans;&#125; 更新操作加法和乘法更新操作整体步骤基本相同，基本为：如果当前区间被完全包含于修改区间，那么只记录标记；否则继续二分更新。 具体时间代码为： 12345678910111213141516171819202122232425262728293031323334353637void add(int p, int l, int r, ll k)&#123; //被完全包含 if (st[p].l &gt;= l &amp;&amp; st[p].r &lt;= r) &#123; st[p].data = (st[p].data + k * (st[p].r - st[p].l + 1)) % mod; st[p].add_tag += k; return ; &#125; //没有被完全包含 lazy_down(p); int mid = (st[p].l + st[p].r) &gt;&gt; 1; if (mid &gt;= l) add(lson(p), l, r, k); if (mid &lt; r) add(rson(p), l, r, k); push_up(p);&#125;//思路同上函数void mul(int p, int l, int r, ll k)&#123; if (st[p].l &gt;= l &amp;&amp; st[p].r &lt;= r) &#123; st[p].data = st[p].data * k % mod; st[p].mul_tag = st[p].mul_tag * k % mod; st[p].add_tag = st[p].add_tag * k % mod; return ; &#125; lazy_down(p); int mid = (st[p].l + st[p].r) &gt;&gt; 1; if (mid &gt;= l) mul(lson(p), l, r, k); if (mid &lt; r) mul(rson(p), l, r, k); push_up(p);&#125; 以上就是常规递归线段树的大体思路和具体实现代码（最值线段树）。总代码被放在了文章最下方。 非递归线段树（zkw线段树）zkw线段树是由神犇zkw在早些时候提出的非递归式线段树。在线段树概念的基础上，优化了常规递归线段树的巨大常数，让线段树的常数变得很小，代码量也同时减少了不少。这里只讨论拥有加法标记的非递归线段树。 建树操作使用两个数组，进一步缩小常数（玄学操作）： 12345678910ll st[MAXN &lt;&lt; 2], add[MAXN &lt;&lt; 2]; //线段树和标记int n, N = 1; //n为原始数据数量，N为**原始数据的起始位置**inline void build()&#123; for (; N &lt; n + 1; N &lt;&lt;= 1); //找到原始数据应该在的位置 for (int i = N + 1; i &lt;= N + n; i++) read(st[i]); //放置原始数据 for (int i = N - 1; i &gt;= 1; i--) st[i] = st[i &lt;&lt; 1] + st[i &lt;&lt; 1 | 1];//从下向上构建线段树&#125; 代码量变小了，意味着信息浓度的增加。这短短三个for语句其实蕴含了不少信息量。 在zkw线段树中，我们将原始数据放在线段树数组的最后方+1的位置，这样将有利于之后的各种操作。 二叉树中，对于节点n，n &#x2F; 2 和 n &#x2F; 2 + 1分别是n的两个儿子节点。位运算中的表述如上代码，不再赘述。 区间分割在zkw线段树中，我们的查询和更新操作将引入两个特殊的节点（或者说是”节点指针”）s和t。 对于目标区间[l, r]，s一开始指向节点(l - 1)，t一开始指向节点(r + 1)。每个小步骤，s和t都指向他们当前的父亲节点 通过在纸上的模拟，我们可以发现： 从s，t的初始位置，直到s和t在本次步骤中父亲节点相同。这个过程中，如果s是它父亲节点的左节点，那么加上他的右边的兄弟；如果t是它父亲节点的右节点，那么加上它左边的兄弟。那么最后加上的所有节点包含的区间，恰好不重不漏地等价于[l, r]。 在zkw线段树中，我们可以发现：对于一个长度是1（r - l + 1的值）的节点（即叶子节点），每次更新他需要加上1次标记。同理，对于一个长度是n的节点，每次更新他需要加上n个标记。 可以推出，从叶子节点向上，每次需要加上的标记数量将增加一倍——即乘二，或者说右移一位。 查询操作和递归式线段树不同，zkw线段树的每次操作都是直接从底部开始向上操作。并且在操作完成后继续上推到根节点。 123456789101112131415161718192021222324252627inline ll query(int l, int r)&#123; int s = N + l - 1, t = N + r + 1; //s节点和t节点 //lNum表示当前s包含的标记个数，rNum表示当t包含的标记个数 //num表示当前层的节点包含的标记个数（从1开始） ll lNum = 0, rNum = 0, num = 1, ans = 0; //如果s和t拥有同一个父亲节点，那么s ^ t == 1，即二进制路径只有最后一位不同 //那么s ^ t ^ 1 == 0，循环停止 //每个循环节，s和t上移，num右移一位 for (; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1, num &lt;&lt;= 1) &#123; if (add[s]) ans += add[s] * lNum; //处理标记 if (add[t]) ans += add[t] * rNum; if (~s &amp; 1) &#123;ans += st[s ^ 1]; lNum += num;&#125; if ( t &amp; 1) &#123;ans += st[t ^ 1]; rNum += num;&#125; //如果s是父亲的左儿子，二进制最后一位应该是0，取反后&amp;1应该是1 //同理，t是父亲的右儿子时，t &amp; 1应该是是1 &#125; for (; s; s &gt;&gt;= 1, t &gt;&gt;= 1) //继续上推到根节点 &#123; ans += add[s] * lNum; ans += add[t] * rNum; &#125; return ans;&#125; 更新操作也是从下向上，一直上推到根节点。每次上推更新自己以应对包含自己的情形。如果s是左||t是右，那么给它的兄弟上标记并更新节点。 12345678910111213141516171819inline void update(int l, int r, ll k)&#123; int s = N + l - 1, t = N + r + 1; ll lNum = 0, rNum = 0, num = 1; for (; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1, num &lt;&lt;= 1) &#123; st[s] += k * lNum; //更新自己 st[t] += k * rNum; //满足条件就更新自己的兄弟 if (~s &amp; 1) &#123;add[s ^ 1] += k; st[s ^ 1] += k * num; lNum += num;&#125; if ( t &amp; 1) &#123;add[t ^ 1] += k; st[t ^ 1] += k * num; rNum += num;&#125; &#125; for (; s; s &gt;&gt;= 1, t &gt;&gt;= 1) //上推到根节点 &#123; st[s] += k * lNum; st[t] += k * rNum; &#125;&#125; 到此，zkw线段树的基本实现已经差不多完成了。 可以看到，zkw线段树比常规线段树的代码量和常数小了很多，但是换来的是每句话信息量的增大。 总结到此，线段树学习小结基本结束。 本小结为自己学习线段树后总结之用，可能并不适合完全不了解线段树的人入门？但是可能会对稍微知道线段树的人有一些帮助。 两个版本的线段树的具体实现代码可以查看我的Github页。 以上。"},{"title":"【旧文归档/捣鼓】更换主题小记","path":"2019/01/theme-changing-note/","text":"用路易大佬的inspire好几个月了，于是就闲得发慌脑子一抽没事找事想要换一个主题—— 接着我就发现：路易nb！ 因为inspire已经集成了许多方便实用的nb功能在里面，包括且不限于音乐播放、评论回复、友链模板、登陆保护、SMTP、统计代码、百度SEO等等功能。失去了inspire的庇护之后，发现这些东西全都需要自己搞。我捣鼓了几个小时之后才勉勉强强搞到能用的样子。在这里把一些关键步骤记录一下。 一、新评论自动通知评论作者这个功能首先需要SMTP支持并且正确设置SMTP服务器。 在安装了WP插件商店中的某个SMTP插件并且配置完成之后，在主题的functions.php中代码最后（不是文件最后）添加如下代码即可： 12345678910111213141516171819202122232425function comment_mail_notify($comment_id) &#123; $comment = get_comment($comment_id); $parent_id = $comment-&gt;comment_parent ? $comment-&gt;comment_parent : &#x27;&#x27;; $spam_confirmed = $comment-&gt;comment_approved; if (($parent_id != &#x27;&#x27;) &amp;&amp; ($spam_confirmed != &#x27;spam&#x27;)) &#123; $wp_email = &#x27;admin@&#x27; . preg_replace(&#x27;#^www\\.#&#x27;, &#x27;&#x27;, strtolower($_SERVER[&#x27;SERVER_NAME&#x27;]));//admin@改成可用的账户 $to = trim(get_comment($parent_id)-&gt;comment_author_email); $subject = &#x27;您在 [&#x27; . get_option(&quot;blogname&quot;) . &#x27;] 的留言有了回应&#x27;; $message = &#x27;&amp;lt;div style=&quot;border-right:#666666 1px solid;border-radius:8px;color:#111;font-size:12px;width:702px;border-bottom:#666666 1px solid;font-family:微软雅黑,arial;margin:10px auto 0px;border-top:#666666 1px solid;border-left:#666666 1px solid&quot;&gt;&amp;lt;div class=&quot;adM&quot;&gt;&amp;lt;/div&gt;&amp;lt;div style=&quot;width:100%;background:#666666;min-height:60px;color:white;border-radius:6px 6px 0 0&quot;&gt;&amp;lt;span style=&quot;line-height:60px;min-height:60px;margin-left:30px;font-size:12px&quot;&gt;您在&amp;lt;a style=&quot;color:#00bbff;font-weight:600;text-decoration:none&quot; href=&quot;&#x27; . get_option(&#x27;home&#x27;) . &#x27;&quot; target=&quot;_blank&quot;&gt;&#x27; . get_option(&#x27;blogname&#x27;) . &#x27;&amp;lt;/a&gt; 上的留言有回复啦！&amp;lt;/span&gt; &amp;lt;/div&gt;&amp;lt;div style=&quot;margin:0px auto;width:90%&quot;&gt;&amp;lt;p&gt;&#x27; . trim(get_comment($parent_id)-&gt;comment_author) . &#x27;, 您好!&amp;lt;/p&gt;&amp;lt;p&gt;您于&#x27; . trim(get_comment($parent_id)-&gt;comment_date) . &#x27; 在文章《&#x27; . get_the_title($comment-&gt;comment_post_ID) . &#x27;》上发表评论: &amp;lt;/p&gt;&amp;lt;p style=&quot;border-bottom:#ddd 1px solid;border-left:#ddd 1px solid;padding-bottom:20px;background-color:#eee;margin:15px 0px;padding-left:20px;padding-right:20px;border-top:#ddd 1px solid;border-right:#ddd 1px solid;padding-top:20px&quot;&gt;&#x27; . nl2br(get_comment($parent_id)-&gt;comment_content) . &#x27;&amp;lt;/p&gt;&amp;lt;p&gt;&#x27; . trim($comment-&gt;comment_author) . &#x27; 于&#x27; . trim($comment-&gt;comment_date) . &#x27; 给您的回复如下: &amp;lt;/p&gt;&amp;lt;p style=&quot;border-bottom:#ddd 1px solid;border-left:#ddd 1px solid;padding-bottom:20px;background-color:#eee;margin:15px 0px;padding-left:20px;padding-right:20px;border-top:#ddd 1px solid;border-right:#ddd 1px solid;padding-top:20px&quot;&gt;&#x27; . nl2br($comment-&gt;comment_content) . &#x27;&amp;lt;/p&gt;&amp;lt;p&gt;您可以点击 &amp;lt;a style=&quot;color:#00bbff;text-decoration:none&quot; href=&quot;&#x27; . htmlspecialchars(get_comment_link($parent_id)) . &#x27;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&amp;lt;/a&gt;&amp;lt;/p&gt;&amp;lt;p&gt;感谢对 &amp;lt;a style=&quot;color:#00bbff;text-decoration:none&quot; href=&quot;&#x27; . get_option(&#x27;home&#x27;) . &#x27;&quot; target=&quot;_blank&quot;&gt;&#x27; . get_option(&#x27;blogname&#x27;) . &#x27;&amp;lt;/a&gt; 的关注，若有任何疑问，欢迎在博客留言，我会一一解答&amp;lt;/p&gt;&amp;lt;p&gt;(此邮件由系统自动发出，请勿回复。)&amp;lt;/p&gt;&amp;lt;/div&gt;&amp;lt;/div&gt;&#x27;; $from = &quot;From: \\&quot;&quot; . get_option(&#x27;blogname&#x27;) . &quot;\\&quot; &amp;lt;$wp_email&gt;&quot;; $headers = &quot;$from\\nContent-Type: text/html; charset=&quot; . get_option(&#x27;blog_charset&#x27;) . &quot;\\n&quot;; wp_mail( $to, $subject, $message, $headers ); &#125;&#125;add_action(&#x27;comment_post&#x27;, &#x27;comment_mail_notify&#x27;); 中间一大坨主要是邮件的格式，除了那一堆东西之外，东西不是太多。 二、登陆地址跳转因为众所周知的原因，讲WP默认的wp-login.php更改是基本操作。基本上有两种比较简单的方法来达到目的： 1.更改php文件的名字将站点内的wp-login.php重命名，然后将php内的几个wp-login.php都替换成新名字，就完事儿了。目前看来好像没什么bug的样子？ 2.要求访问添加键值在主题的functions.php内追加： 12345function login_protec()&#123; if ($_GET[&#x27;login&#x27;] != &#x27;please&#x27;) header(&#x27;Location: https://baidu.com/&#x27;);&#125;add_action( &#x27;login_enqueue_scripts&#x27; , &#x27;login_protec&#x27; ); 保存之后，就必须访问 dctewi.com&#x2F;wp-login.php?login&#x3D;please 才可以进入登陆界面，否则将会跳转到baidu.com。当然，键值对中的key和value可以随意更改，网址也一样。 三、友链页面及友链管理换主题之后有一种怅然若失的感觉。突然发现是因为原来的友链界面不管用了，不仅如此，原来仪表盘内的链接管理项也不存在了。慌的一批的我东凑西凑才找到了解决办法： 1.开启wp隐藏起来的链接管理器熟悉的functions.php内追加： 1add_filter(&#x27;pre_option_link_manager_enabled&#x27;,&#x27;__return_true&#x27;); 然后就可以发现仪表盘内出现了链接管理器！是不是很简单（）？ 2.建立页面模板页面模板原则上可以放在wp路径内的任何一个位置。复制一个主题带的page.php。重命名副本后，在文件内添加： 12345&lt;?php/*Template Name: template-name*/?&gt; 然后wp就可以将这个php识别为一个页面模板文件。在新建页面的时候就可以看到，高级（指gutenberg编辑器，经典编辑器在选项卡中部）选项卡内有了一个名字叫做template-name的模板。通过这个模板创建的页面会用模板php来排版而不是默认的page.php。 3.一个看起来海星的友链模板这个模板是我到处凑出来的，在接连的修改中解决了一些本来存在的问题（比如li标签没有厚度，footer跑到友链上方，高度不协调导致形状感人等等）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php get_header(); ?&gt;&lt;?php/*Template Name: 友情链接*/?&gt;&lt;style&gt; .link-content li &#123; display: inline-block; //让li标签有宽度 vertical-align: top; //让li标签以顶部对齐 text-align: center; width: 100px; height: 150px; //让li标签的高度固定 font-size:14px; margin-bottom:10px; list-style-type: none; &#125; .link-content li img &#123; border-radius:100%; margin-bottom:5px; width:64px; height=64px; transition:0.5s; -webkit-transtion:1.5s; //设置变换时间 &#125; .link-content li span &#123; display:block; //让span成为块元素 &#125; .link-content li:hover img &#123; transform:rotate(360deg); //简单的hover旋转 -webkit-transform:rotate(360deg); &#125;&lt;/style&gt;&lt;section id=&quot;content&quot;&gt;&lt;?php the_post(); ?&gt; &lt;article class=&quot;sp&quot;&gt;&lt;hgroup class=&quot;p_lt p_a&quot;&gt; &lt;header class=&quot;p_t&quot;&gt; &lt;h2&gt;&lt;a href=&quot;&lt;?php the_permalink(); ?&gt;&quot;&gt; &lt;?php the_title(); ?&gt; &lt;/a&gt;&lt;/h2&gt; &lt;/header&gt; &lt;/hgroup&gt;&lt;div class=&quot;sp_c&quot;&gt;&lt;div&gt; &lt;?php//获取友链并且随机排序 $bookmarks = get_bookmarks(&#x27;title_li=&amp;orderby=rand&#x27;); //打印格式 if ( !empty($bookmarks) )&#123; echo &#x27;&lt;ul class=&quot;link-content clearfix&quot;&gt;&#x27;; foreach ($bookmarks as $bookmark) &#123; $friendimg = $bookmark-&gt;link_image; if(empty($friendimg))&#123; echo &#x27;&lt;li&gt;&lt;a href=&quot;&#x27; . $bookmark-&gt;link_url . &#x27;&quot; title=&quot;&#x27; . $bookmark-&gt;link_description . &#x27;&quot; target=&quot;_blank&quot; &gt;&#x27;. get_avatar($bookmark-&gt;link_notes,64) . &#x27;&lt;span class=&quot;sitename&quot;&gt;&#x27;. $bookmark-&gt;link_name .&#x27;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&#x27;; &#125; else &#123; echo &#x27;&lt;li&gt;&lt;a href=&quot;&#x27; . $bookmark-&gt;link_url . &#x27;&quot; title=&quot;&#x27; . $bookmark-&gt;link_description . &#x27;&quot; target=&quot;_blank&quot; &gt;&#x27;. &#x27;&lt;img src=&quot;&#x27;. $bookmark-&gt;link_image. &#x27;&quot; /&gt;&#x27; . &#x27;&lt;span class=&quot;sitename&quot;&gt;&#x27;. $bookmark-&gt;link_name .&#x27;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&#x27;; &#125; &#125; echo &#x27;&lt;/ul&gt;&#x27;; &#125;//打印完毕 ?&gt;&lt;/div&gt;&lt;?php the_content(); ?&gt;&lt;/div&gt;&lt;/article&gt;&lt;?php comments_template( &#x27;&#x27;, true ); ?&gt;&lt;/section&gt;&lt;?php get_footer(); ?&gt; 然后把我原来的传送门页面套用这个模板就欧凯了，页面会自动获取连接管理器内的链接。连接图片优先获取链接的 图像地址 项，如果没有填写图像地址，则会以 备注 中的邮箱来获取Gravatar头像，如果还是不存在则使用默认头像。具体效果可以看我的友链界面。 以上，做了一些微小的工作，让我的站点得以换个外观。但是我还是想说：坐等路易新主题pix，路易nb！ 这么搞了搞感觉自己的php水瓶有所提高了（大雾）。"},{"title":"【捣鼓】Ubuntu及vim、gcc配置笔记","path":"2018/12/vim-setup/","text":"最近突然发觉ICPC比赛中的机器都是Ubuntu环境，而我却从来都没有用过Linux操作系统。所以便打算在实验室的电脑上捣鼓一番，熟悉一下比赛中使用的环境。 二、Ubuntu的安装及简单配置我选择的操作系统是Ubuntu 18.04.1 LTS。从Ubuntu的官网下载系统iso文件之后，用Rufus刻录到一个新买的优盘当作启动盘（其实2G就足够了，但是学校京东竟然已经没有这么小的优盘了）。然后在开机时进入BIOS选择从U盘启动，选择直接覆盖安装Ubuntu，接着就是一顿傻瓜式安装引导，Ubuntu的安装就完成了。 在设置里稍微设置了一下可以自定义的选项。值得一提的是，18.04版本的Ubuntu在安装的时候如果选择了中文，那么他会将&#x2F;home&#x2F;下的文件夹也建立成中文的，这会在终端使用过程中导致一系列问题。要解决这个问题，需要在区域与语言设置里，先将系统语言设置成中文并重启，在开机完成后会提示是否要替换成英文文件夹。替换成英文文件夹后再换成中文环境并重启，这次重启后选择保留原样即可保留英文文件夹名称。 三、Code::blocks的安装及简单配置一开始我是想继续使用code::blocks这样的IDE。但是code::blocks在半个小时之内崩溃了三次让我身心俱疲，于是就进入了vim的大坑。这里还是简单地记录一下code::blocks的安装方法: （以下安装过程在终端中完成） 123456sudo apt-get install build-essential //build-essential是一些基础的编译环境的集成包，GCC等工具都被包含在内sudo apt-get install codeblocks //安装codeblocks的基础包sudo apt-get install codeblocks codeblocks-contrib //安装codeblocks的插件包（自动补全、自动对齐、自动缩进等） CB默认将Xterm作为调试终端，如果想要美化一下，使用Ubuntu的Gnome终端的话，则只需要在CB的环境设置里将Terminal to launch console programs选项栏填写成：gnome-terminal-t $TITLE -x即可。 到此，CB已经基本安装完成，简单设置之后就可以使用辽。但可能是由于兼容性还是什么的问题，我在Ubuntu上使用codeblocks的半小时内codeblocks崩溃了三次。让我十分恐惧，所以就想到用另一个据说会用之后十分好用的编译套装：vim + gcc + gdb。 四、vim的安装及配合gcc的简单应用。很早就听说vim是一个会用之后运笔如飞的文本编辑器，今天终于有机会来使用一波这个广受好评（？）的文本编辑器辽。 vim 的安装与其他软件包无异,没有安装 vim 的机器在终端键入 sudo apt-get install vim 再 y一下即可完成安装。安装完成后,键入 vim ,就可以看到 vim 的主页面 (?) 辽: 在 Linux 中, Ctrl + C 可以强制中断进程, Ctrl + Z 可以将进程挂起。当在 vim 里出不去的时候可以用这两个快捷键找出出路(大雾)。 vim 有三种模式:命令模式,输入模式和底线命令模式。 命令模式就是刚启动 vim 的模式。此时的键盘操作会被 vim 识别为命令而不是字符。大小写的i , a , o 分别可以以不同的光标位置进入编辑模式。输入模式则是编辑文件的模式。此时的键盘操作是正常的操作文件。 Esc 键可以退出到命令模式。底线命令模式,是在命令模式下输入英文冒号 : 后进入的模式。此模式下,可以使用单个或者多字符命令的模式，可用的命令非常多。 Enter 输入命令后或者 Esc 键可以返回命令模式。 要用 vim 舒服的编辑 cpp 文件,则需要简单的配置一下: 在终端输入 vim ~/.vimrc 就会进入 vim 的配置文件。如果是去参加比赛，不适合仔仔细细地一个一个配置，所以简单地撰写以下内容基本就可以很舒服的写代码了: 123456syntax on # 语法高亮set mouse=a # 允许鼠标点击set cindent # 使用 C 缩进set tabstep=4 # 一个 tab 是 4 个空格(也可以写成 set ts=4 )set shiftwidth=4 # 自动缩进是 4 个空格(也可以写成 set sw=4 )set nu # 显示行号(没想明白为啥是 nu 这两个字母) vim 常用的快捷键很多,但是比赛时需要用到的命令其实也没有太多: 1234567891011121314151617181920212223242526272829303132i 从当前光标进入编辑模式I 从当前行第一个非空格进入编辑模式a 从当前光标的下一个字符进入编辑模式A 从当前行最后一个字符处进入编辑模式o 在当前行下方另起一行进入编辑模式O 从当前行上方另起一行进入编辑模式x 删除光标处的字符X 删除光标前的字符dd 删除( delete )当前行( 5dd 删除当前行向下 5 行)yy 复制( yank )当前行( 5yy 复制当前行向下 5 行)p 粘贴( paste )到当前行下P 粘贴( paste )到当前行上u 撤销( undo )Ctrl + r 重做( redo ). (英文句号)继续做上次操作j k 上下移动光标h l 左右移动光标:w 写入( write )即保存:q 退出( quit ):q! 强制退出:wq 保存并退出 另外, :w 可以在后边加入文件名参数来另存为/word 查找当前光标下的第一个 word?word 查找当前光标上的第一个 word:%s/oldword/newword/g 将文件中的所有 oldword 替换成 newword:%s/oldword/newword/gc 将文件中的所有 oldword 替换成 newword ,在替代前让用户确认:a,bs/oldword/newword/g 将 a 到 b 行中的所有 oldword 替换成 newword ,当然也有对应的 gc 版本,其中若 b 为 $ 则表示文件末尾。n 正向重复上次搜寻N 反向重复上次搜寻 编写、编译运行一个 cpp 文件的一般流程一般是这样的: 1234567891011121314151617181920211. 用终端进入想要存放代码的位置( cd 或者直接在指定文件夹打开终端)。2. 使用 vim filename.cpp 命令来打开一个 cpp 文件(若不存在则创建)。3. 编写代码。4.1 在本终端窗口编译代码, :wq 保存并退出 vim 就可以进行操作 5 。4.2 Ctrl + Shift + N 新建终端窗口编译代码,需要 :w 保存后新建终端窗口执行操作 5 。5. 终端中键入 g++ filename.cpp -o filename -std=c++11 -O2 来编译可执行文件。上句命令即为 g++ 的编译指令,第一个参数是代码文件名, -o 制定目标名称为 flename (缺省值为 filename.out ),-std=c++11 来指定 c++11 标准, -O2 开启氧气优化。若要使用 gdb 调试,则最好加上 -g 编译选项来更好地支持调试功能。6.1 可以使用 ./filename 来直接运行编译出的可执行文件。6.2.1 也可以使用 gdb 工具: gdb filename 来进行 gdb 调试:6.2.2 r 运行程序。更多的调试命令可以查看紫书 ( 刘汝佳 著《算法竞赛入门经典 第 2 版》 )P463 附表。 到此,在 Ubuntu 上的编译环境已经基本配置完成,然后就可以在 ICPC 中徜 pa 徉 xing 了。本文为冻葱 Tewi 记录回顾之用,若能够对你的学习工作进程有所帮助,不胜荣幸。 以上。"},{"title":"【旧文归档/停更】冻葱的月记 - 201808","path":"2018/09/record-201808/","text":"八月三十号从濮阳出发抵达郑州，整个三十号和三十一号都在整理宿舍之类。而九月二号就开始军训了。接连不断的训练使我身心俱疲，一直都没来得及写这个月的月记。 今晚补上. 咕咕咕，时间太长了，都忘记辣。 以后不会咕了，真的（哭哭）。 就此绝版！"},{"title":"【算法】从群论到快速幂和快速乘","path":"2018/08/quick-exp/","text":"换一个角度看快速幂和快速乘。 群在抽象代数中具有基本的重要地位。许多代数结构，包括环、域和向量空间都可以看作是在群的基础上添加新的运算和公理而形成的。群的概念在数学的很多分支都有出现，而且群论的研究方法也对抽象代数的其他分支有重要影响。 在数学中，群是由一个集合以及一个二元运算所组成的，符合以下四个性质（称为“群公理”）的代数结构。即封闭性，结合律，单位元和逆元存在。 对于**群$(G,·)$**，该群由一个集合G和一个二元运算·组成。对于该群，群公理表现为： 封闭性： 对于任意a, b ∈ G，有a · b ∈ G 。 结合律： 对于任意a, b, c ∈ G，有(a · b) · c &#x3D; a · (b · c) 。 单位元： 存在e ∈ G，使得对于所有元素a ∈ G总有 e · a &#x3D; a · e &#x3D; a成立。 逆元存在： 对于任意a ∈ G，存在元素b使得总有a · b &#x3D; b · a &#x3D; e，此处e为单位元。 幺半群是一种类似群的结构。幺半群不一定满足逆元存在公理，但是其余的三个群公理均满足。即幺半群$(G, )$满足*{封闭性， 结合律， 单位元}**。又因为幺半群的要求比群要少，所以所有的群都是幺半群。幺半群的例子:(非负整数，加法运算)，(正整数，乘法运算)。 所以，这和标题里的快速幂和快速乘又有什么关系呢？ 因为，快速幂算法就可以从幺半群的角度来分析。 对于幺半群$&lt;N^*, *&gt;$(N*为非零自然数，*是乘法运算)，计算a的k次幂，当k &#x3D; 0时为1，其余情况为k个n相乘。根据结合律（强行），我们可以在至多$O(log(k))$的时间内把k拆成二进制下的1，然后使用至多$O(log(k))$次乘法合并这些幂次。 用代码表达会更直观一些： 123456789101112131415typedef long long ll;ll q_exp(ll a, ll k, ll mod)&#123; if (!b) return 1; //任何实数的0次幂都是1; ll ans = 1; //结果变量 while (k) //拆k &#123; if (k &amp; 1) ans = ans * a % mod; //如果现在的k是个奇数，则ans多乘一个a; a = a * a % mod; //a自乘 k &gt;&gt;= 1; //继续拆k &#125; return ans; //返回结果&#125; 在这个过程中，我们用到了一下几个性质： 乘法 满足封闭性 乘法 满足结合律 乘法 下有单位元(即1) 即我们在不知不觉中已经使用到了幺半群的相关内容。而如果我们稍加思考，将上述幺半群$&lt;N^*, *&gt;$魔改成$&lt;Z, +&gt;$呢？因为加法也满足以上的几个性质(单位元是0)，所以我们就引申到了另一个神奇的算法——快速乘。这种神奇的算法在罗宾米勒算法中，为了防止$a * b % mod$时溢出而使用过。当$a * b$的结果连long long都放不下的时候，求$a * b % mod$ 的结果就需要用到这种方法。 123456789101112131415typedef long long ll;ll q_mul(ll a, ll b, ll mod)&#123; if (!b) return 0; //任何数乘0都是0 ll ans = 0; //结果变量 while (b) //拆b &#123; if (b &amp; 1) ans = (ans + a) % mod; //如果现在的b是个奇数，则ans多加一个a; a = (a + a) % mod; //a自加 b &gt;&gt;= 1; //继续拆b &#125; return ans;//返回结果&#125; 这样我们就得到了快速乘算法的代码。 以上，快速幂和快速乘其实就这么结束了，所以抽象代数真的很厉害。"},{"title":"【旧文归档】冻葱的月记 - 201807","path":"2018/07/record-201807/","text":"什么？七月已经要过去了？ 以上，所以冻葱这个沙雕一直到7.31下午五点还没有意识到七月已经到最后一天了的事实。本次月记结束。 （略略略） 话说回来，这个七月发生在我身上的大事儿挺多的，甚至有不少都和我的生命轨迹息息相关。比如紧张刺激地从报志愿到等待，从被提档到录取一段时间。这应该算是我目前阶段中最为重要的一件事情了，所幸，郑大网开一面地录取了我这个只考了573的自招学生。我悬着的心总算放了下来。 当然，各种小事儿也不少，杂七杂八乱七八糟一大堆。前半个月主要继续搞minecraft的相关内容，服务器周目也从三周目到了五周目。目前的服务器加载的是一套末日生存类的mod，因为稍微有那么一点点难，导致大家很难发展233。另外，七月中旬我搞了个VPS，从面板服的拘束中逃离了出来（顺便也能搭飞机场），反正我访问的整体速度也快了很多。此外，通知书到手之后，在cy学长的帮助下，我和同学sxy一起提前来到了郑大的ACM实验室学习。一是感受一下ACM的气氛，二是在这里可以得到一个很好的学习环境。而又因为在实验室的电脑很足够使用，根本不用把戴尔小本本带在身上，所以我就搭建了一个个人用的冻葱云来传递我寝室在笔记本上和实验室的台式机上需要用的工具和写题的代码。一开始采用的是git上的一个小型开源项目，界面也蛮好看的，操作也挺顺手。但是唯一也是很致命的一点不足就是，每次都需要登陆后才能操作文件。导致整个过程比较繁琐。于是后来又改成了kod cloud，虽然界面没有之前的那个那样炫酷，但是好歹避免了在实验室每次都需要输入长长的一串密码才能够操作文件的尴尬。进行了一些简单的自定义之后，也挺好用的。 Emmm，写出来之后怎么感觉自己一个月根本没干多少事儿呢。？剩下的时间大概都混迹在steam上摸鱼了吧（逃）。说到steam，这个月我的确小小地搞了搞steam社区的相关内容。这个新号虽然账户年限并不如我之前那个遗失的大号久，但是在我的栽培下，已经比之前的号之前太多了（泪，流了下来。）。而对逼格提升最显著的就是从steamCN学来的长艺术展柜咯2333。 以上，冻葱的七月就这样一晃而过。摸了。 附图：两个版本的我的艺术展柜（因为被抢镜而震惊不已的戴安娜.jpg）。"},{"title":"【旧文归档】冻葱的月记 - 201806","path":"2018/06/record-201806/","text":"这半个月没有更新博客其实是有原因的（笑），因为这半个月实在是太忙了。 高考后怎么比高考前还累，我怕不是放了假暑假。 急急忙忙地架设mc的服务器，然后因为高估了服务器一天暴毙，瞬间开启二周目。二周目也挺匆忙的，而且还被塞尔达剑技这个mod坑了一波。在群里一群肝帝的爆肝下，二周目成功地活下来了——一个星期。 眼看着服里大多数人都毕业了，而且二周目的确很匆忙。所以我就整合了两天开启了三周目。三周目在我的修修补补下，算是运营了挺长的时间的。打算把这个周目做长一点，起码两三个月把。 在群里小伙伴的支持下，我又给自己的服务器升了一档。之前每到下午和晚上，十五六个人的时候会出现掉ping的情况也缓解了很多。我爱这里。 在我自己开服之前我玩的服务器的腐竹联系上了我，并且分给我了一个远程主机用来开服务器。真的不胜感激，正因如此，我的一些想法的实现也有了实现的基础。首先是面板服不支持更换jvm参数而让我的登录器直接登陆的幻想化为泡影，而现在又有了实现的可能。其次，我之前准备开个分服务器来存储大家在各个周目的优秀建筑，搞游戏活动，组织比赛的目标也得以实现。这些东西正好也不会太占服务器资源，感谢腐竹。 高考成绩也出了，考的不错，比三模高了五六十分，回到了我高一二的巅峰水平。山大没拿到A所以还是上不了，但是郑大应该没什么问题了。还有两天就开始填报志愿了，时间是真的快。 成绩出来之后，爹妈带着给我配了台电脑。专业原因，选择了笔记本而不是台式。最终敲定了DELL游匣G3-3579 i7-8570H GTX-1050Ti，128固态+1024机械。单8G内存，店家又送了条256的固态，我又把自带的5400转的机械硬盘换成了7200转的。到大学之后再攒出来个8G内存安上就完全进化完成了。多亏了豆喵的指导我才得以知晓我这台机器的进化路线，也幸亏我这台机器的进化路线不是很长。 避免肥宅化行动也在有条不紊地进行着。家里我哥给我搞了两张健身房的月卡，又给我报销了十几节私教课程。健身什么的有在做。 mc开服的工作大抵已经稳定了，我也开始修炼画画和建模了。画画还是SAI，但是建模方面，本来是想用Maya，但是看到价格之后果断选择了开源的Blender。用了一下，感觉还行，于是就开始学习了。 当然，本职工作——竞赛也在学习。打了两把Code Force，但是好久不碰了的我毫无疑问地掉分到了小学生。嘛，所以现在先在洛谷之类的oj里恢复水平中。 这个月也没什么了。看着码出来的这几段流水账一样的月记，一股全选删除的冲动涌上心头。哎，还是算了。 附本周目几张风景图（点击图片放大）： 以上"},{"title":"【旧文归档】冻葱的月结 - 201805","path":"2018/06/record-201805/","text":"五月底——其实已经是上个月底了——的我正在为了高考做最后的准备，没去机房，手机也在家。所以就基本没怎么管过博客。整个五月也没有发生什么值得记录下来的大事件，整个人都泡在知识的海洋里遨游（?）。况且现在其实六月已经过去了一半，五月的事情差不多都没什么印象了，月记也不能乱编不是，所以这篇月记就这样水了算了（逃）。 高考就这么突然过去了。其实说实话，并没有多少豁然开朗的感觉，没有天地异象，也没有什么大的变化。只有一种稍微的放松感。而要在人生路上有所建树，就不能过于怠惰。八号考完之后马不停蹄地准备十号山大的自招，山大自招完成之后就开始搞Minecraft服务器的问题——大约花了两天时间。现在服务器基本已经能玩了，虽然一开始想要实现的一些特性并没有都完成，但是也差不了多少。算是我开始搞事的一个比较良好的开端。 嘛，无论如何，也算是new life.start();。最近要解决的首要问题是十七号郑大的自招。其实说是准备，也没有什么明确的复习&#x2F;准备提纲，一切都是靠自己的感觉来准备。总之不管如何，相信自己就好了。 以上"},{"title":"【旧文归档】冻葱的月结 - 201804","path":"2018/04/record-201804/","text":"日子一天天有的没的地过着，如果不经常写在纸上、铺成句子的话，一段时间之后，这段日子就早已被时间的洪流淹没在历史的海洋里，再也回想不起来哪怕一丝一毫。这就是我为什么经常写日记，而这也是我为什么开始周期性的写这些月结。 转眼之间，四月份就这么从指尖溜过，变成了过往。冻葱马上就要迎接他人生中最重要的一次考试之一——高考了。高考倒计时牌子刚被设置到楼梯口、教室后、黑板上等各种各样的地方的时候，上边还写着大大的二百八十多天。可是稍不留神，上边只剩下了三十有余——短短的五个星期。 回首整个四月，冻葱也并没有做什么值得记录的事情。硬要总结些什么东西的话，那就稍微整理一下这个月都干了些什么吧。 四月初，接连着三月底，一直都在忙自主招生的事情。然而其实我并没有留给四月份多少工作，大部分的材料准备都在三月末完成了。三月二十六号，郑大和山大的自招简章发布之后，只是进行了一些资料上传的工作。而且今年郑大的要求与往年不同，并不要求邮寄材料，所以早早准备的纸质材料其实并没有派上什么用场。但是也并不是一帆风顺——第一次申请的时候，并没有吧会考成绩单放在附加材料里，等到盖完章准备提交的时候才发现。于是连忙取消了申请，重新填报了一次。反正也总算是有惊无险，一切工作进行的相对还算顺利（虽然申请了两次，盖了两次章，跑了两次办公室和政教科）。但是品尝了一番普通班歧视的感觉，不止一次地被“优班家长”和某“咨询老师”歧视——例如“普通班也想着自招吗”、“你成绩没到前5%也能自招吗”之类的质疑屡见不鲜（优班了不起啊）——我想他们可能对自主招生的受众有什么误解，所以也就没有太在意，也就当做涨了涨见识。 搞定了自主招生报名的事情，就开始了紧张刺激的最后六十天冲刺生活。每天就只是很单调的学习——从早晨五点半起床开始，到晚上十一点睡觉结束。每天没有什么变化，简简单单，虽然难免会有些枯燥，但是总体上来讲还算是积极向上的。不过中间被英语老师叫去给她的女儿——也就是我的同班同学帮忙报名自主招生的事情（几乎全是我弄的）。搞自招的时候因为要到机房报名，所以意外地又多了很多碰电脑的机会。于是在装饰博客的时候，先是遇见了蜜汁路易大佬，并且入手了大佬开发的inspire主题，然后顺手入门了入门css和js之类的脚本语言。我的博客页就这么迷迷地初成规模了。 四月的上旬和中旬就这么过去了。整个下旬最重要的一件事情大概就是三模了——高考前的最后一次大型考试。（然而冻葱在下旬前几天正式接触了python）四月二十六、二十七号是三模，紧接着是短暂的五一假期——高考前的最后一次节假日。四月二十九号下午第三节课放假，紧接着五月一号中午两点就要回来继续考语文周清。嘛，毕竟还有三十多天就要高考了，一切想要偷懒的娱乐的念头都是邪恶的（话是这么说来着hhh）。五一假期结束后，就是三轮复习——也就是最后的三十天冲刺了，加油！ 冻葱的第一次电子档的月结大概就这么结束了。综上，这就是一个高三狗在高考前六十天到八十天的有ku趣zao生活。"},{"title":"【旧文归档】冻葱滚去闭关修炼了","path":"2018/04/dc-is-gonna-study/","text":"还有45天冻葱就要高考了。 不能浪费自招的机会，文化课要拚命去干了。 不能懈怠。稳住，加油——是时候用上全部的力量了！！ 六月见！"},{"title":"【旧文归档】突然诈尸的zz冻葱","path":"2018/04/respawned-dc/","text":"冻葱这个蒟蒻从NOIP2017回来之后就颓了沉浸在文化课的海洋里准备迎接今年六月份的高考，所以这个博客也一直没怎么管过。最近自招，做课件等等一系列的事件导致我突然又有机会每天来机房水一会儿了。 回看自己各种半途而废的滑稽举动，一种懊悔和痛苦充斥着心头。自己的高中生涯即将结束，而冻葱在以往的近18年里，仿佛什么果实都没有结出过，就这么浑浑噩噩地度过了，没有留下过一丝痕迹。 人生苦短，茫茫人海中，属于一个人的空间实在太少太少，而值得一个人去探索的东西却又太多太多。每次看到自己计划单上一个又一个的项目，都会一种难以言喻的沉闷贴在心头无法自拔。于是我便想要表达——但不久之后，自己又会对自己刚表达出来的什么不满，于是又是一次放弃。 我需要一次改变。这个世界上，值得我去敬仰和学习的前辈和大师实在太多太多。保持谦逊和谨慎，保持清醒的头脑。保持输出，不怕嘲笑。不能再在自己的妄想中缩头缩脑——敢于迈向位置的远方，就是一次伟大的成功。 我是有一个梦想的。我想要在这个世界上留下自己的一点印记。为了这点，我需要去学习和实践的事情还有很多很多——除去我稍有涉猎的码力之外，建模、编曲和绘画等等自己几乎还一无所知。接下来的日子，自己要加油了。 但是，在这离高考只有短短五十五天的日子里，我当前最为重要的任务自然就是六月七号的那次考试了。稳住自己的身心，为自己默默地加个油。而后，璀璨星空。 少しだけても、世界をもっと綺麗するために。"},{"title":"【旧文归档】距离NOIp2017还有十天","path":"2017/11/10-days-to-noip2017/","text":"十一月就这么冷不丁地冲到了我的面前，蒟蒻冻葱便慌张地开始了最后的努zheng力zha。 说实话，心里特别没底。最后的这几天，也没什么心情写什么填坑记了。回首我这两年的OI生涯，不长不短，中间甚至还颓废了几个月的时间。弱校没集训课，老师只能凑封闭学校每天中午的空闲时间讲课，练习赛也并不多，资源肯定是比不过强校的。浑浑噩噩地靠着老师领门，学长指路，自己钻研走到了现在的一个地步。去年的NOIp以二等草草收场了，当时的自己比现在更加稚嫩和蒟蒻，甚至在竞赛前两周才刚刚对单元最短路懵懵懂懂。但现在的我，比起去年并没有多少实质的长进。并没有学多少高级的算法、也没有学多少骗分的技巧——好像自己会的只是模拟和暴力似的。离竞赛越近，越感觉当初想要拿一等的愿望更加远了，就越心慌。 但既然走到了这一步，没有也不能有任何退缩的想法。不断地为自己鼓劲，努力地让自己不去想那些可怕的事情。因为无论自己的状态如何，NOIp总会如期而至，它不会因为一个人的状况而改变分毫。事到如今，尽力地复习巩固旧知识，再多学一些简单实用的结构&#x2F;算法，是我唯一的选择。 加油冻葱，向上看、向前走、争取你应该得到的，不要怕、不要慌、人活着总是要遇到各种各样的关卡。我们能做的，只有为自己的生活点燃花火。"}]